<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>wubianluoye</title>
    <link>https://github.com/wubianluoye/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="%5Bobject%20Object%5D" rel="hub"/>
    <description></description>
    <pubDate>Tue, 05 Dec 2017 05:53:55 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>react与redux,dva</title>
      <link>https://github.com/wubianluoye/2017/12/05/react%E4%B8%8Eredux-dva/</link>
      <guid>https://github.com/wubianluoye/2017/12/05/react%E4%B8%8Eredux-dva/</guid>
      <pubDate>Tue, 05 Dec 2017 03:55:38 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;strong&gt;一.  State和 Props&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  state是状态机。&lt;/p&gt;
&lt;p&gt;  应该包括：那些可能被组件的事件处理器改变并触发用户界面更新的数据，譬如需要对用户输入,服务器请求或者时间变化等作出响应。&lt;/p&gt;
&lt;p&gt;  不应该包括：计算所得数据、React组件（在render()里使用props和state来创建它）、基于props的重复数据（尽可能保持用props来做作为唯一的数据来源，把props保存到state中的有效的场景是需要知道它以前的值得时候,因为未来的props可能会变化）。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>一.  State和 Props</strong></p><p>  state是状态机。</p><p>  应该包括：那些可能被组件的事件处理器改变并触发用户界面更新的数据，譬如需要对用户输入,服务器请求或者时间变化等作出响应。</p><p>  不应该包括：计算所得数据、React组件（在render()里使用props和state来创建它）、基于props的重复数据（尽可能保持用props来做作为唯一的数据来源，把props保存到state中的有效的场景是需要知道它以前的值得时候,因为未来的props可能会变化）。</p><a id="more"></a><p>  props： 父级向子级传递数据的方式。</p><p><strong>二.  有状态组件和无状态组件（纯函数组件）</strong></p><p>  有状态组件</p><p>  通过React.createClass或者es6的class继承React.Component创建的组件。特性：具备完整的生命周期及实例化过程、支持this及ref指向。</p><p>  无状态组件：</p><p>  即stateless component( pure function Component)。以函数返回值方式方式创建的组件。特点： 无实例化过程及生命周期、无this及ref指向、函数接受props及context两个参数。</p><p>  实践模式</p><p>  创建多个只负责渲染数据的无状态(stateless)组件,在他们的上层创建一个有状态(stateful)组件并把它的状态通过props传给子级。有状态的组件封装了所有的用户交互逻辑，state中处理状态的变化, 而这些无状态组件只负责声明式地渲染数据.</p><p><strong>三.  受控组件、非受控组件及混合组件</strong></p><p>  有许多的web组件可以被用户的交互发生改变，比如：<code>&lt;input&gt;，&lt;select&gt;</code>。这些组件可以通过输入一些内容或者设置元素的value属性来改变组件的值。但是，因为React是单向数据流绑定的，这些组件可能会变得失控：</p><p>  1.一个维护它自己state里的value值的<code>&lt;Input&gt;</code>组件无法从外部被修改</p><p>  2.一个通过props来设置value值的<code>&lt;Input&gt;</code>组件只能通过外部控制来更新。</p><p>  受控组件：</p><p>  一个受控的<code>&lt;input&gt;</code>应该有一个value属性。渲染一个受控的组件会展示出value属性的值。 </p><p>  一个受控的组件不会维护它自己内部的状态，组件的渲染单纯的依赖于props。也就是说，如果我们有一个通过props来设置value的<code>&lt;input&gt;</code>组件，不管你如何输入，它都只会显示props.value。换句话说，你的组件是只读的。</p><p>  在处理一个受控组件的时候，应该始终传一个value属性进去，并且注册一个onChange的回调函数让组件变得可变。</p><p>  非受控组件</p><p>  一个没有value属性的<code>&lt;Input&gt;</code>就是一个非受控组件。通过渲染的元素，任意的用户输入都会被立即反映出来。非受控的<code>&lt;Input&gt;</code>只能通过OnChange函数来向上层通知自己被用户输入的更改。</p><p>  混合组件</p><p>  同时维护props.value和state.value的值。props.value在展示上拥有更高的优先级，state.value代表着组件真正的值。</p><p>  目的：</p><p>  1、支持传入值； </p><p>  2、可控：组件外部修改props可改变input组件的真实值及显示值； </p><p>  3、非可控：输入框中输入值，可同时改变input组件的真实值及显示值。</p><p><strong>四.  redux和dva</strong></p><p>  Redux</p><ol><li><p>Actions、Reducers 和 Store</p><p>action 可以理解为应用向 store 传递的数据信息（一般为用户交互信息）。在实际应用中，传递的信息可以约定一个固定的数据格式，比如: Flux Standard Action。 dispatch(action) 是一个同步的过程：执行 reducer 更新 state -&gt; 调用 store 的监听处理函数。如果需要在 dispatch 时执行一些异步操作（fetch action data），可以通过引入 Middleware 解决。</p><p>reducer 实际上就是一个函数：(previousState, action) =&gt; newState。用来执行根据指定 action 来更新 state 的逻辑。reducer 不存储 state, reducer 函数逻辑中不应该直接改变 state 对象, 而是返回新的 state 对象。</p><p>store 是一个单一对象，redux中只有唯一一个store实例。主要作用：</p><ol><li>管理应用的 state</li><li>通过 store.getState() 可以获取 state</li><li>通过 store.dispatch(action) 来触发 state 更新</li><li>通过 store.subscribe(listener) 来注册 state 变化监听器</li></ol></li></ol><ol><li>Dva</li></ol><p>数据流向</p><p>数据的改变发生通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，当此类行为会改变数据的时候可以通过 dispatch 发起一个 action，如果是同步行为会直接通过 Reducers 改变 State ，如果是异步行为（副作用）会先触发 Effects 然后流向 Reducers 最终改变 State，所以在 dva 中，数据流向非常清晰简明，并且思路基本跟开源社区保持一致（也是来自于开源社区）。</p><p>Modele</p><p>State</p><p>type State = any</p><p>State 表示 Model 的状态数据，通常表现为一个 javascript 对象（当然它可以是任何值）；操作的时候每次都要当作不可变数据（immutable data）来对待，保证每次都是全新对象，没有引用关系，这样才能保证 State 的独立性，便于测试和追踪变化。<br>在 dva 中你可以通过 dva 的实例属性 _store 看到顶部的 state 数据，但是通常你很少会用到:<br>    const app = dva();<br>    console.log(app._store); // 顶部的 state 数据</p><p>Action</p><p>type AsyncAction = any</p><p>Action 是一个普通 javascript 对象，它是改变 State 的唯一途径。无论是从 UI 事件、网络回调，还是 WebSocket 等数据源所获得的数据，最终都会通过 dispatch 函数调用一个 action，从而改变对应的数据。action 必须带有 type 属性指明具体的行为，其它字段可以自定义，如果要发起一个 action 需要使用 dispatch 函数；需要注意的是 dispatch 是在组件 connect Models以后，通过 props 传入的。</p><pre><code>dispatch({  type: &apos;add&apos;,});</code></pre><p>dispatch 函数</p><p>type dispatch = (a: Action) =&gt; Action</p><p>dispatching function 是一个用于触发 action 的函数，action 是改变 State 的唯一途径，但是它只描述了一个行为，而 dipatch 可以看作是触发这个行为的方式，而 Reducer 则是描述如何改变数据的。<br>在 dva 中，connect Model 的组件通过 props 可以访问到 dispatch，可以调用 Model 中的 Reducer 或者 Effects，常见的形式如：</p><pre><code>dispatch({  type: &apos;user/add&apos;, // 如果在 model 外调用，需要添加 namespace  payload: {}, // 需要传递的信息    });</code></pre><p>Reducer</p><p>type Reducer<s, a=""> = (state: S, action: A) =&gt; S</s,></p><p>Reducer（也称为 reducing function）函数接受两个参数：之前已经累积运算的结果和当前要被累积的值，返回的是一个新的累积结果。该函数把一个集合归并成一个单值。</p><p>Reducer 的概念来自于是函数式编程，很多语言中都有 reduce API。如在 javascript 中：</p><pre><code>[{x:1},{y:2},{z:3}].reduce(function(prev, next){    return Object.assign(prev, next);})//return {x:1, y:2, z:3}</code></pre><p>在 dva 中，reducers 聚合积累的结果是当前 model 的 state 对象。通过 actions 中传入的值，与当前 reducers 中的值进行运算获得新的值（也就是新的 state）。<br>需要注意的是 Reducer 必须是纯函数，所以同样的输入必然得到同样的输出，它们不应该产生任何副作用。并且，每一次的计算都应该使用immutable data，这种特性简单理解就是每次操作都是返回一个全新的数据（独立，纯净），所以热重载和时间旅行这些功能才能够使用。</p><p>Effect</p><p>Effect 被称为副作用，在我们的应用中，最常见的就是异步操作。它来自于函数编程的概念，之所以叫副作用是因为它使得我们的函数变得不纯，同样的输入不一定获得同样的输出。</p><p>dva 为了控制副作用的操作，底层引入了redux-sagas做异步流程控制，由于采用了generator的相关概念，所以将异步转成同步写法，从而将effects转为纯函数。至于为什么我们这么纠结于 纯函数，如果你想了解更多可以阅读Mostly adequate guide to FP，或者它的中文译本JS函数式编程指南。</p><p>Subscription</p><p>Subscriptions 是一种从 源 获取数据的方法，它来自于 elm。</p><p>Subscription 语义是订阅，用于订阅一个数据源，然后根据条件 dispatch 需要的 action。数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。</p><pre><code>import key from &apos;keymaster&apos;;...app.model({  namespace: &apos;count&apos;,  subscriptions: {    keyEvent(dispatch) {      key(&apos;⌘+up, ctrl+up&apos;, () =&gt; { dispatch({type:&apos;add&apos;}) });    },  }});</code></pre><p>Router</p><p>这里的路由通常指的是前端路由，由于我们的应用现在通常是单页应用，所以需要前端代码来控制路由逻辑，通过浏览器提供的 History API 可以监听浏览器url的变化，从而控制路由相关操作。</p><p>dva 实例提供了 router 方法来控制路由，使用的是react-router。</p><pre><code>import { Router, Route } from &apos;dva/router&apos;;app.router(({history}) =&gt;  &lt;Router history={history}&gt;    &lt;Route path=&quot;/&quot; component={HomePage} /&gt;  &lt;/Router&gt;);</code></pre><p>Route Components</p><p>在组件设计方法中，我们提到过 Container Components，在 dva 中我们通常将其约束为 Route Components，因为在 dva 中我们通常以页面维度来设计 Container Components。</p><p>所以在 dva 中，通常需要 connect Model的组件都是 Route Components，组织在/routes/目录下，而/components/目录下则是纯组件（Presentational Components）。</p><p><strong>五.  hoc</strong></p><p>  HOC(全称Higher-order component)是一种React的进阶使用方法，主要还是为了便于组件的复用。HOC就是一个方法，获取一个组件，返回一个更高级的组件。</p><p>  在React开发过程中，发现有很多情况下，组件需要被”增强”，比如说给组件添加或者修改一些特定的props，一些权限的管理，或者一些其他的优化之类的。而如果这个功能是针对多个组件的，同时每一个组件都写一套相同的代码，明显显得不是很明智，所以就可以考虑使用HOC。</p><p>  一个最简单的HOC实现是这个样子的：</p><p>  HOC可以做什么？</p><p>  代码复用，代码模块化</p><p>  增删改props</p><p>  渲染劫持</p><p>  1.增删改props</p><p>  可以通过对传入的props进行修改，或者添加新的props来达到增删改props的效果。</p><p>  比如你想要给wrappedComponent增加一个props，可以这么搞：</p><p>  这样，你就可以在你的组件中使用message这个props:</p><p>  2.渲染劫持</p><p>  这里的渲染劫持并不是你能控制它渲染的细节，而是控制是否去渲染。由于细节属于组件内部的render方法控制，所以你无法控制渲染细节。</p><p>  比如，组件要在data没有加载完的时候，现实loading…，就可以这么写：</p><p>  这个样子，在父级没有传入data的时候，这一块儿就只会显示loading…,不会显示组件的具体内容</p><p><strong>六. 项目中的实践</strong></p><ol><li><p>合理使用有状态组件及无状态组件。在使用redux或者dva的场景下，理论上所有的组件都可以封装为无状态组件（少数需要生命周期控制或者上文提到的混合式组件除外），model中封装数据、异步effects及同步reducers，通过connect绑定到对应的组件上。<br>最佳实践： router中getcomponent中定义的组件我们称之为路由组件，一般路由组件会通过connect绑定model中定义的state及组件中定义的方法到该组件的props上。其他方式定义的为非路由组件，非路由组件尽量避免使用connect，而是通过路由组件或者其他上层通过props传递数据进行渲染。</p></li><li><p>理解subscription, effects及reducers中各自的功能职责。</p></li><li><p>package.json中定义的dependency，需要深入研究，避免重复造轮子。</p></li><li><p>全局观及合理的组件规划。</p></li></ol>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/05/react%E4%B8%8Eredux-dva/#disqus_thread</comments>
    </item>
    
    <item>
      <title>react-router的一些问题</title>
      <link>https://github.com/wubianluoye/2017/12/05/react-router%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
      <guid>https://github.com/wubianluoye/2017/12/05/react-router%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Tue, 05 Dec 2017 03:54:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;react-router 有很多个版本，所以有很多个写法，在npm安装时，需要根据route的版本来找api，不然要被坑死！&lt;/p&gt;
&lt;p&gt;react-router 4 版本&lt;a href=&quot;https://reacttraining.cn/web/guides/quick
        
      
      </description>
      
      <content:encoded><![CDATA[<p>react-router 有很多个版本，所以有很多个写法，在npm安装时，需要根据route的版本来找api，不然要被坑死！</p><p>react-router 4 版本<a href="https://reacttraining.cn/web/guides/quick-start" target="_blank" rel="noopener">https://reacttraining.cn/web/guides/quick-start</a></p><p> 这个不知道是几的版本<a href="https://react-guide.github.io/react-router-cn/，貌似安装后里面没有Link模块。demo报错" target="_blank" rel="noopener">https://react-guide.github.io/react-router-cn/，貌似安装后里面没有Link模块。demo报错</a></p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/05/react-router%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>react的属性与状态</title>
      <link>https://github.com/wubianluoye/2017/12/05/react%E7%9A%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%8A%B6%E6%80%81/</link>
      <guid>https://github.com/wubianluoye/2017/12/05/react%E7%9A%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%8A%B6%E6%80%81/</guid>
      <pubDate>Tue, 05 Dec 2017 03:44:14 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;code&gt;this.props&lt;/code&gt; 表示那些一旦定义，就不再改变的特性，而 &lt;code&gt;this.state&lt;/code&gt; 是会随着用户互动而产生变化的特性。&lt;/p&gt;
&lt;p&gt;属性 props&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this.props&lt;/code&gt;获取属性&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><code>this.props</code> 表示那些一旦定义，就不再改变的特性，而 <code>this.state</code> 是会随着用户互动而产生变化的特性。</p><p>属性 props</p><p><code>this.props</code>获取属性</p><a id="more"></a><p>状态 state</p><p><code>this.stste</code>获取状态</p><p>属性是在一个组件被声明，尚未初始化的时候就被父组件赋予的，并且不可以自己修改</p><p>在react中，state属于组件的自有属性</p><p>getInitialState初始化每个实例特有的状态</p><p><code>setState({name:&quot;red&quot;})</code>来更新组件状态 </p><p>每次状态更新之后，react会对组件进行一个diff的算法，查看一下是否需要更新dom   如果需要更新dom，就会重新执行render方法</p><p>react数据传递使用两种事物进行传递：</p><p>1.属性（props）     在组件外部传入，或者内部设置，组件内部通过this.props获得</p><p>2.状态（state）     在组件内部设置或者更改，组件内部通过this.state获得</p><p>属性是在一个组件被声明，尚未初始化的时候就被父组件赋予的，并且不可以自己修改，就像咱们的姓氏是爸爸赋予的，爸爸可以改，但是你自己不能改</p><p>属性就是为了使用数据</p><p>如何让一个组件有属性 3种</p><p>1.在渲染的时候给它传递 2.父组件给子组件传入  3.组件自己初始化属性</p><p>属性被传递的方式一般是在组件被调用的时候被传入</p><p>可以通过在ReactDOM.render的时候去给组件传入一个提前设置好的数据，键值对方式</p><pre><code>var d=&apos;my component&apos;;var e={name:&quot;allen&quot;,age:18};var f=[0,1,2]ReactDOM.render(&lt;App title={d} info={e} arr={f}/&gt;,document.getElementById(&apos;app&apos;))</code></pre><p>获取的时候也很简单，创建组件里有一个东东叫<code>this.props</code></p><p>里面保存了所有传入的数据，使用时记得加{}  不加的话，react不认识</p><p>还有一种情况就是三个点   …</p><pre><code> var props={     name:&apos;allen&apos;,     age:18}&lt;Hello {...props}  sex={&apos;male&apos;}/&gt; </code></pre><p><code>this.props</code> 就是这样的<code>{name:&#39;allen&#39;,age:18,sex:&#39;male&#39;}</code></p><p>这是根据别人给传的，那么怎么能自己初始的时候就有呢，当然可以</p><pre><code>getDefaultProps:function(){     return {          name:&apos;tom&apos;     }},render:function(){}</code></pre><p>这个时候的数据也就会保存在this.props里，那么，会不会覆盖呢？</p><p>会的，在外面引入的数据会把自己自带的数据给替换掉</p><p>做个小例子吧，比如说现在要这么做，一个组件里呢，我要显示这样的东西，如果你有name属性，我就显示你的名字，没有就显示‘world’</p><p>三元表达式、  组件的方法返回值赋值变量去使用变量  、   直接调用这个方法    、     || 运算符</p><p><strong>demo：</strong></p><pre><code>var App=React.createClass({    getName:function(){        if(this.props.name){            return this.props.name;        }else{            return &apos;world&apos;    }},render:function(){    var name=this.getName();    return (        &lt;div&gt;            &lt;span&gt;Hello,{this.props.name?this.props.name:&apos;world&apos;}&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;Hello,{name}&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;Hello,{this.getName()}&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;Hello,{this.props.name||&apos;name&apos;}&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;Hello,            {(function(obj){                if(obj.props.name){                    return obj.props.name;                }else{                    return &apos;world&apos;                }            })(this)}            &lt;/span&gt;&lt;br/&gt;            &lt;/div&gt;            )        }    })    var props={name:&quot;allen&quot;,age:18};    ReactDOM.render(&lt;App {...props}/&gt;,document.getElementById(&apos;app&apos;))</code></pre><p>状态（state）在组件内部设置或者更改，组件内部通过this.state获得</p><p>state，就这个货  指的呢是事物所处的状况  为了让状态改变的时候，去改变结果</p><p>状态呢是由事物自行处理的，不断变化的</p><p>在react中，state属于组件的自有属性</p><p>getInitialState初始化每个实例特有的状态</p><p><code>setState({name:&quot;red&quot;})</code>来更新组件状态 </p><p>每次状态更新之后，react会对组件进行一个diff的算法，查看一下是否需要更新dom   如果需要更新dom，就会重新执行render方法</p><pre><code>var App1=React.createClass({    render:function(){        return (            &lt;div&gt;                &lt;h4 &gt;app1 {this.props.name}&lt;/h4&gt;            &lt;/div&gt;            )    }})    var App2=React.createClass({        getInitialState:function(){            return {                name:&apos;allen&apos;,                age:18            }        },    changeState:function(){        this.setState({name:&apos;tom&apos;})    },    inpChangeState:function(ev){        this.setState({name:ev.target.value})    },    render:function(){        return (            &lt;div&gt;                &lt;h2&gt;{this.state.name}&lt;/h2&gt;                &lt;h2&gt;{this.state.age}&lt;/h2&gt;                &lt;button onClick={this.changeState}&gt;change&lt;/button&gt;                &lt;input type=&quot;text&quot; onChange={this.inpChangeState}/&gt;                &lt;App1 {...this.state}/&gt;            &lt;/div&gt;        )    }    })ReactDOM.render(&lt;App2/&gt;,document.getElementById(&apos;app&apos;))</code></pre><p><strong>refs</strong> </p><p>可以dom结构上dom做标记</p><pre><code>this.refs.refname</code></pre><p>那么这两个东西，状态和属性都有什么相同点和不同点呢，来研究一下</p><p>相似点：都是纯js对象，都会触发render更新，都具有确定性（状态/属性相同，结果相同）</p><p>不同点：  </p><p>属性能从父组件获取，状态不能</p><p>属性可以由父组件修改，状态不能</p><p>属性能在内部设置默认值     ，状态也可以</p><p>属性不在组件内部修改   ，状态要改</p><p>属性能设置子组件初始值  ，状态不可以</p><p>属性可以修改子组件的值，状态不可以</p><p>状态只和自己相关，由自己维护</p><p>属性不要自己修改，可以从父组件获取，也可以给子组件设置</p><p>组件在运行时自己需要修改的数据其实就是状态而已</p><p><strong>设置属性值时使用双花括号</strong></p><p>由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。</p><p>循环输出数据//</p><pre><code>var Tiezhu=React.createClass({    render:function(){        var arr=[1,2,3,4,5,6,7,8,9,10];        var aarry=[];        for(var i=0;i&lt;arr.length;i++){            aarry.push(&lt;h1&gt;{arr[i]}&lt;/h1&gt;)        }        return (            &lt;div&gt;                {aarry}            &lt;/div&gt;        )    }})ReactDOM.render(&lt;Tiezhu/&gt;,document.getElementById(&quot;app2&quot;));</code></pre><p>refs  </p><p>可以dom结构上dom做标记</p><pre><code>this.refs.refname</code></pre><p>相似点：都是纯js对象，都会触发render更新，都具有确定性（状态/属性相同，结果相同）</p><p>不同点：  属性能从父组件获取，状态不能<br>               属性可以由父组件修改，状态不能<br>               属性能在内部设置默认值     ，状态也可以<br>               属性不在组件内部修改   ，状态要改<br>               属性能设置子组件初始值  ，状态不可以<br>               属性可以修改子组件的值，状态不可以</p><p>状态只和自己相关，由自己维护<br>属性不要自己修改，可以从父组件获取，也可以给子组件设置</p><p>组件在运行时自己需要修改的数据其实就是状态而已</p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/05/react%E7%9A%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%8A%B6%E6%80%81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>react组件间通信</title>
      <link>https://github.com/wubianluoye/2017/12/05/react%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/</link>
      <guid>https://github.com/wubianluoye/2017/12/05/react%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/</guid>
      <pubDate>Tue, 05 Dec 2017 03:39:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;父组件可以给子组件传递属性，&lt;/p&gt;
&lt;p&gt;父组件可以调用子组件的方法 ref，因为ref可以形成一条链，所以父辈组件可以调用到任何子孙组件的方法，其实可以直接更改状&lt;/p&gt;
&lt;p&gt;态，不要这么做，会降低组件的内聚度，提高组件间的耦合度&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>父组件可以给子组件传递属性，</p><p>父组件可以调用子组件的方法 ref，因为ref可以形成一条链，所以父辈组件可以调用到任何子孙组件的方法，其实可以直接更改状</p><p>态，不要这么做，会降低组件的内聚度，提高组件间的耦合度</p><a id="more"></a><p>子组件可以调用父组件的方法，前提是父组件已经把方法传递给子组件了</p><p>这样的话，只要外层有至少一个共同的父组件，这两个组件就都可以通过共同的父组件进行通信</p><pre><code>React.addons.LinkedStateMixin         为 react提供的 双向绑定的react-with-addons.min.jsmixins:[React.addons.LinkedStateMixin]&lt;input type=&quot;text&quot; onClick={this.linkState(&apos;name&apos;)} style={{margin:"5px 0"}}/&gt;</code></pre><p>双向绑定。。<br>为单个数据挂载。。</p><pre><code>sexc:function(e){    this.setState({        sex:e.target.value    })}</code></pre><p>一个函数处理多个事件</p><pre><code>aal:function(type){    var that=this;    return function(e){        var obj={};        obj[type]=e.target.value;        that.setState(obj);    }}&lt;div&gt;&lt;input type=&quot;text&quot; onChange={this.aal(&apos;age&apos;)} style={{margin:"5px 0"}} /&gt;{this.state.age}&lt;input type=&quot;text&quot; onChange={this.aal(&apos;name&apos;)} style={{margin:"5px 0"}} /&gt;{this.state.age}&lt;input type=&quot;text&quot; onChange={this.aal(&apos;sex&apos;)} style={{margin:"5px 0"}} /&gt;{this.state.age}&lt;/div&gt;</code></pre>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/05/react%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>keep-alive使复用子组件不刷新</title>
      <link>https://github.com/wubianluoye/2017/12/05/keep-alive%E4%BD%BF%E5%A4%8D%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%8D%E5%88%B7%E6%96%B0/</link>
      <guid>https://github.com/wubianluoye/2017/12/05/keep-alive%E4%BD%BF%E5%A4%8D%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%8D%E5%88%B7%E6%96%B0/</guid>
      <pubDate>Tue, 05 Dec 2017 03:05:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;问题：在写路由时，通过跳转到同一路由改变id来改变数据，发现只有第一次的数据有用，其他的点击还是第一个路由进来的数据。&lt;/p&gt;
&lt;p&gt;原因：在&lt;router-view&gt;&lt;/router-view&gt;外面加了一层&lt;keep-alive&gt;&lt;/keep-alive&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;keep-alive&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;/keep-alive&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>问题：在写路由时，通过跳转到同一路由改变id来改变数据，发现只有第一次的数据有用，其他的点击还是第一个路由进来的数据。</p><p>原因：在<router-view></router-view>外面加了一层<keep-alive></keep-alive></p><pre><code>&lt;keep-alive&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;</code></pre><a id="more"></a><p>keep-alive 缓存组件在内存中，再次进入该页面不会重新渲染，用于保存页面的原始状态。<br>这就是原因！！！</p><p>解决方法有几种：</p><p>1.删除keep-alive</p><p>2.保留keep-alive，使用$watch()进行检测</p><p>3.保留keep-alive，使用beforeRouteUpdate进行检测</p><p>4.保留keep-alive，使用beforeRouteEnter 进行检测</p><pre><code>beforeRouteEnter (to, from, next) {  next(vm =&gt; {    vm.getdata()  })}</code></pre>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/05/keep-alive%E4%BD%BF%E5%A4%8D%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%8D%E5%88%B7%E6%96%B0/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
