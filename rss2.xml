<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>wubianluoye</title>
    <link>https://github.com/wubianluoye/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="%5Bobject%20Object%5D" rel="hub"/>
    <description></description>
    <pubDate>Fri, 19 Apr 2019 11:17:39 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>boom</title>
      <link>https://github.com/wubianluoye/2019/04/19/boom/</link>
      <guid>https://github.com/wubianluoye/2019/04/19/boom/</guid>
      <pubDate>Fri, 19 Apr 2019 11:13:28 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>https://github.com/wubianluoye/2019/04/19/boom/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Vuex一篇就够了</title>
      <link>https://github.com/wubianluoye/2019/04/19/Vuex%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</link>
      <guid>https://github.com/wubianluoye/2019/04/19/Vuex%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</guid>
      <pubDate>Fri, 19 Apr 2019 09:35:34 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Vuex-概念篇&quot;&gt;&lt;a href=&quot;#Vuex-概念篇&quot; class=&quot;headerlink&quot; title=&quot;Vuex 概念篇&quot;&gt;&lt;/a&gt;Vuex 概念篇&lt;/h2&gt;&lt;h3 id=&quot;Vuex-是什么？&quot;&gt;&lt;a href=&quot;#Vuex-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Vuex 是什么？&quot;&gt;&lt;/a&gt;Vuex 是什么？&lt;/h3&gt;&lt;p&gt;Vuex 是一个专为 Vue.js 应用程序开发的&lt;strong&gt;状态管理模式&lt;/strong&gt;。它采用&lt;strong&gt;集中式存储管理应用的所有组件的状态&lt;/strong&gt;，并以相应的&lt;strong&gt;规则&lt;/strong&gt;保证状态以一种可预测的方式发生变化。&lt;/p&gt;
&lt;h3 id=&quot;什么是“状态管理模式”？&quot;&gt;&lt;a href=&quot;#什么是“状态管理模式”？&quot; class=&quot;headerlink&quot; title=&quot;什么是“状态管理模式”？&quot;&gt;&lt;/a&gt;什么是“状态管理模式”？&lt;/h3&gt;&lt;p&gt;从软件设计的角度，就是以一种统一的约定和准则，对全局共享状态数据进行管理和操作的设计理念。你必须按照这种设计理念和架构来对你项目里共享状态数据进行CRUD。所以所谓的“状态管理模式”就是一种软件设计的一种架构模式（思想）。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Vuex-概念篇"><a href="#Vuex-概念篇" class="headerlink" title="Vuex 概念篇"></a>Vuex 概念篇</h2><h3 id="Vuex-是什么？"><a href="#Vuex-是什么？" class="headerlink" title="Vuex 是什么？"></a>Vuex 是什么？</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用<strong>集中式存储管理应用的所有组件的状态</strong>，并以相应的<strong>规则</strong>保证状态以一种可预测的方式发生变化。</p><h3 id="什么是“状态管理模式”？"><a href="#什么是“状态管理模式”？" class="headerlink" title="什么是“状态管理模式”？"></a>什么是“状态管理模式”？</h3><p>从软件设计的角度，就是以一种统一的约定和准则，对全局共享状态数据进行管理和操作的设计理念。你必须按照这种设计理念和架构来对你项目里共享状态数据进行CRUD。所以所谓的“状态管理模式”就是一种软件设计的一种架构模式（思想）。</p><a id="more"></a><h3 id="为什么需要这种“状态管理模式”应用到项目中呢？"><a href="#为什么需要这种“状态管理模式”应用到项目中呢？" class="headerlink" title="为什么需要这种“状态管理模式”应用到项目中呢？"></a>为什么需要这种“状态管理模式”应用到项目中呢？</h3><p>现如今，流行组件化、模块化开发，多人开发各自组件的时候，不难保证各个组件都是唯一性的，多个组件共享状态肯定是存在的，共享状态又是谁都可以进行操作和修改的，这样就会导致<strong>所有对共享状态的操作都是不可预料的</strong>，后期出现问题，进行 debug 也是困难重重，往往我们是尽量去避免全局变量。</p><p>但大量的业务场景下，不同的模块（组件）之间确实需要共享数据，也需要对其进行修改操作。也就引发软件设计中的矛盾：<strong>模块（组件）之间需要共享数据</strong> 和 <strong>数据可能被任意修改导致不可预料的结果</strong>。</p><p>为了解决其矛盾，软件设计上就提出了一种设计和架构思想，将全局状态进行统一的管理，并且需要获取、修改等操作必须按我设计的套路来。就好比马路上必须遵守的交通规则，右行斑马线就是只能右转一个道理，统一了对全局状态管理的唯一入口，使代码结构清晰、更利于维护。</p><blockquote><p>Vuex 是借鉴了 Flux 、Redux 和 The Elm Architecture  架构模式、设计思想的产物。<br><img src="https://yqfile.alicdn.com/ae7aa24f8dc2cad21a18c820938d4a5cbec18a34.jpeg" alt="ae7aa24f8dc2cad21a18c820938d4a5cbec18a34"></p></blockquote><h3 id="什么情况下我应该使用-Vuex？"><a href="#什么情况下我应该使用-Vuex？" class="headerlink" title="什么情况下我应该使用 Vuex？"></a>什么情况下我应该使用 Vuex？</h3><p>不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。应用够简单，最好不要使用 Vuex。一个简单的 <a href="https://link.juejin.im/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomponents.html%23%25E5%258A%25A8%25E6%2580%2581%25E7%25BB%2584%25E4%25BB%25B6" target="_blank" rel="noopener">global event bus </a> (父子组件通信，父组件管理所需的数据状态)就足够您所需了。构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。</p><blockquote><p>个人见解，什么时候用？管你小中大型应用，我就想用就用呗，一个长期构建的小型应用项目，谁能知道项目需求以后会是什么样子，毕竟在这浮躁的时代，需求就跟川剧变脸一样快，对不对？毕竟学习了 Vuex 不立马用到项目实战中，你永远不可能揭开 Vuex 的面纱。项目中使用多了，自然而然就会知道什么时候该用上状态管理，什么时候不需要。老话说的好熟能生巧，你认为呢？<br>（括弧 – 先了解好Vuex 一些基本概念，然后在<strong>自己的项目</strong>中使用过后，再用到你公司项目上，你别这么虎一上来就给用上去了～）</p></blockquote><h2 id="Vuex-基本使用篇"><a href="#Vuex-基本使用篇" class="headerlink" title="Vuex 基本使用篇"></a>Vuex 基本使用篇</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vuex -S</span><br></pre></td></tr></table></figure><p>项目全局中任何地方使用 Vuex, 需要将 Vuex 注册到 Vue 实例中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><h3 id="Vuex-上车前的一个例子"><a href="#Vuex-上车前的一个例子" class="headerlink" title="Vuex 上车前的一个例子"></a>Vuex 上车前的一个例子</h3><p>上车规则：</p><ol><li>每一个 Vuex 应用的核心就是 store（仓库），一个项目中必须只有一个 store 实例。包含着你的应用中大部分的状态 (state)。</li><li>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。</li></ol><p>Vuex 和单纯的全局对象有以下两点不同：<br>（1） Vuex 的状态存储是响应式的。Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>（2）不能直接改变 store 中的状态。（重要的事情多来一遍）</p><p><strong>上一个例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex) // Vuex 注册到 Vue 中</span><br><span class="line"></span><br><span class="line">// 创建一个 store</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // 初始化 state</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line"> // 改变状态唯一声明处</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment: state =&gt; state.count++,</span><br><span class="line">    decrement: state =&gt; state.count--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  // 从根组件将 store 的实例注入到所有的子组件</span><br><span class="line">  store,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">        // Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态,</span><br><span class="line">        // 每当状态 count 发生变化，都会重新求取计算</span><br><span class="line">      return this.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment () &#123;</span><br><span class="line">      this.$store.commit(&apos;increment&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement () &#123;</span><br><span class="line">      this.$store.commit(&apos;decrement&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>state</code> 一个对象管理应用的所有状态，唯一数据源（SSOT, Single source of truth），必须前期初始化就定义好，不然后面在来修改设置  <code>state</code>，程序就不会捕获到 <code>mutations(突变的意思)</code> 所以数据也就不会又任何的更新，组件上也无法体现出来。</p><p>获取 store 管理的状态， 因为在 Vue 实例化的时候将 Vuex store 对象 注入了进来 ，所以任何地方都可以通过 <code>this.$store</code> 获取到 store, <code>this.$store.state</code> 来获取状态对象， <code>this.$store.commit</code> 来触发之前定义好的 mutations 中的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$store.state(&apos;count&apos;) // =&gt; 0</span><br><span class="line"></span><br><span class="line">this.$store.commit(&apos;increment&apos;) // =&gt; 1</span><br></pre></td></tr></table></figure><p>通过提交 <code>mutation</code> 的方式，而非直接改变 <code>store.state.count</code>,  使用 <code>commit</code> 方式可以让 Vuex 明确地追踪到状态的变化，利于后期维护和调试。<br>通过了解 <code>state</code> （状态，数据）和 <code>mutations</code> （修改数据唯一声明的地方，类似 SQL 语句）知道了 Vuex 最重要的核心两部分，然后通过掌握 gttter、action、module 来让 Vuex 更加的工程化、合理化来适应更大型的项目的状态管理。</p><h3 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h3><p><code>mapState</code>  可以干什么呢？字面意思<strong>状态映射</strong>，通过 <code>mapState</code> 可以更加快捷方便帮我们生成计算属性，拿上面的例子进行演示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      return this.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// 使用 mapState</span><br><span class="line"></span><br><span class="line">import &#123; mapState &#125; from &apos;vuex&apos; // 需要先导入</span><br><span class="line"></span><br><span class="line">computed: mapState([</span><br><span class="line">    // 箭头函数方式</span><br><span class="line">  count: state =&gt; state.count ,</span><br><span class="line"></span><br><span class="line">    // or 传字符串参数方式, &apos;count&apos; 等同于 state =&gt; state.count</span><br><span class="line">    countAlias: &apos;count&apos;</span><br><span class="line"></span><br><span class="line">    // 获取状态后，你还需要和当前组件别的属性值时,就必须使用常规函数的写法了, 只有这样才能获取到当前组件的 this</span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      return state.count + this.localCount</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>当前计算属性名称和状态名称相同时，可以传递一个字符串数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">    // 映射 `this.count` 为 `this.$store.state.count`</span><br><span class="line">  &apos;count&apos;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>以上使用 <code>mapState</code> 辅助函数后，整个 <code>computed</code> 计算属性都成了 <code>state</code> 状态管理聚集地了， 组件里并不是所有的计算属性都需要被状态管理化，还是有很多计算属性是不需要状态管理的数据的，那如何将它与局部计算属性混合使用呢？</p><p>因为 <code>mapState</code> 函数返回的是一个对象。所以我们使用对象扩展运算符就可以把局部计算属性和 <code>mapState</code> 函数返回的对象融合了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    count: state =&gt; state.count</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">   localComputed () &#123;</span><br><span class="line">       /* ... */</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><blockquote><p>上面以讲述过 state 了，这里就不过多的说明。</p></blockquote><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p><code>Getter</code> 就是 <code>Store</code> 状态管理层中的计算属性，获取源 <code>State</code> 后，希望在对其进行一些包装，再返回给组件中使用。也是就将直接获取到 <code>State</code> 后在 <code>computed</code> 里进行再次的过滤、包装逻辑统统提取出放到 <code>Getter</code> 里进行，提高了代码的复用性、可读性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    return this.$store.state.todos.filter(todo =&gt; todo.done).length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提取到 <code>Getter</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; id: 1, text: &apos;...&apos;, done: true &#125;,</span><br><span class="line">      &#123; id: 2, text: &apos;...&apos;, done: false &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  //  `Getter` 默认第一个参数为 `state`:</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter( todo =&gt; todo.done )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//  组件中获取，通过属性访问</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">      return this.$store.getters.doneTodos.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>️ 注意： getter 在通过属性访问时是作为 Vue 的响应式系统的一部分进行缓存。</p></blockquote><p>Getter 还接受其他 getter 作为第二个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; id: 1, text: &apos;...&apos;, done: true &#125;,</span><br><span class="line">      &#123; id: 2, text: &apos;...&apos;, done: false &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter( todo =&gt; todo.done )</span><br><span class="line">    &#125;,</span><br><span class="line">    // 第二个参数为 getters</span><br><span class="line">    doneTodosLength: (state, getters) =&gt; &#123;</span><br><span class="line">      return getters.doneTodos.length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>还可以通过给 Getter 传递参数获取特定的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">    getTodoById: state =&gt; id =&gt; &#123;</span><br><span class="line">      return state.todos.find( todo =&gt; todo.id === id )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件内调用方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$store.getters.getTodoById(2) // =&gt; &#123; id: 2, text: &apos;...&apos;, done: false &#125;</span><br></pre></td></tr></table></figure><blockquote><p>️ 注意：getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p></blockquote><h4 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h4><p>和前面 <code>mapState</code> 辅助函数作用和使用上基本相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapGetters &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">// getter 名称和 计算属性名称相同的情况下，可以传递字符串数组</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapGetters([</span><br><span class="line">      &apos;doneTodos&apos;</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 传递对象的方式</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapGetters(&#123;</span><br><span class="line">      doneTodos: &apos;doneTodos&apos;,</span><br><span class="line">        getTodoById: &apos;getTodoById&apos; // 此处传递回来的是一个函数，所以在使用的时候 =&gt; &#123;&#123; getTodoById(2) &#125;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p><strong>不能直接修改状态，需要通过 Vuex store 中声明的 Mutations 里的方法修改状态。</strong> 更改 Vuex 的 store 中的状态的唯一方法是提交 <code>mutation</code>。<code>mutation</code> 是一个对象， 含有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。<br>回调函数就是我们实际进行状态更改的地方，默认接受 state 作为第一个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 1</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    // increment 事件类型（type）名称，increment() 回调函数</span><br><span class="line">    // increment: function (state) &#123;&#125;  原本写法</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      // 变更状态</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>mutation handler</code> 不能被直接调用，需要通过 <code>store.commit()</code> 来通知我需要触发一个 <code>mutation handler</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$store.commit(&apos;increment&apos;)</span><br></pre></td></tr></table></figure><p><code>mutation</code> 接收参数必须只能两个，超出的都无法获取；第二个参数推荐传递的是一个对象，来接收更多的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.$store.commit(&apos;increment&apos;, 10)</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line"></span><br><span class="line">this.$store.commit(&apos;increment&apos;, &#123; num: 10 &#125;)</span><br></pre></td></tr></table></figure><p>对象风格的提交方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.$store.commit(&#123;</span><br><span class="line">  type: &apos;increment&apos;,</span><br><span class="line">    num: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Mutation-需要遵守-Vue-的响应规则"><a href="#Mutation-需要遵守-Vue-的响应规则" class="headerlink" title="Mutation 需要遵守 Vue 的响应规则"></a>Mutation 需要遵守 Vue 的响应规则</h4><p>Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p><ol><li>最好提前在你的 store 中初始化好所有所需属性（state 中的属性）。</li><li>当需要在对象上添加新属性时，你应该返回的是一个新对象<br>* 使用 Vue.set(obj, ‘newProp’, 123)，或者<br>* 以新对象替换老对象。例如： <code>Object.assgin({}, state.obj, newProps)</code> 、对象扩展运算符 <code>state.obj = {...state.obj, newProp: 123 }</code></li></ol><h4 id="mapMutation-辅助函数"><a href="#mapMutation-辅助函数" class="headerlink" title="mapMutation 辅助函数"></a>mapMutation 辅助函数</h4><p>使用方式跟 <code>mapState</code> 和 <code>mapGetters</code> 基本相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapMutations &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 传递字符串数组，同名哦～</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class="line"></span><br><span class="line">      // `mapMutations` 也支持载荷：</span><br><span class="line">      &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&apos;incrementBy&apos;, amount)`</span><br><span class="line">    ]),</span><br><span class="line"></span><br><span class="line">    // 传递对象</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式就跟 <code>methods</code> 其他普通方法一样，通过 <code>this.&lt;methodName&gt;</code> 来调用。</p><blockquote><p>️ 注意：<br><strong>mutation 必须是同步函数</strong>，修改 state 必须是同步的、同步的、同步的。<br>如果是异步的，当触发 mutation 的时候，内部的回调函数还没有被调用，根本不知道实际执行在何处，很难追踪起问题。（实质上任何在回调函数中进行的状态的改变都是不可追踪的。<br>Vuex 也提供了异步操作的解决方案， 需要将异步操作提取出来放入到 Action 里进行操作。而 Mutation 只负责<strong>同步事务</strong>。</p></blockquote><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>在之前也讲述了，Action 是用来处理异步操作的。这里在详细说明一下 Action 的基本使用。</p><p>Action 类似于 mutation， 不同在于:</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。(不直接修改状态，修改状态还是需要通过 mutation)</li><li>Action 可以包含任意异步操作。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">     // 实践中，经常用到参数解构来简化代码， increment (&#123;commit&#125;) &#123; commit(&apos;&apos;) &#125;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(&apos;increment&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象（并不是真正的 store 本身），因此可以调用 <code>store.commit</code> 进行提交 mutation， 或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 <code>state</code> 和 <code>getters</code>。<br><strong>触发Action</strong></p><p>Action 通过 <code>store.dispatch</code> 方法触发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">this.$store.dispatch(&apos;increment&apos;)</span><br><span class="line"></span><br><span class="line">// 以传递额外参数分发</span><br><span class="line">store.dispatch(&apos;incrementAsync&apos;, &#123;</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 以对象形式分发</span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: &apos;incrementAsync&apos;,</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>与服务器数据异步请求基本在 Action 里进行， 然后通过 Mutation 来同步应用状态<code>state</code></p><h4 id="mapAction-辅助函数"><a href="#mapAction-辅助函数" class="headerlink" title="mapAction 辅助函数"></a>mapAction 辅助函数</h4><p>和 <code>mapMutions</code> 使用方式基本一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapActions &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`</span><br><span class="line"></span><br><span class="line">      // `mapActions` 也支持载荷：</span><br><span class="line">      &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)`</span><br><span class="line">    ]),</span><br><span class="line"></span><br><span class="line">    // 传递对象</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h4><p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p><p>通过返回一个 Promise 对象来进行组合多个 Action。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        commit(&apos;someMutation&apos;)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(&apos;actionA&apos;).then(() =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>利用 <code>async / await</code>，我们可以如下组合 action：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 假设 getData() 和 getOtherData() 返回的是 Promise</span><br><span class="line"></span><br><span class="line">actions: &#123;</span><br><span class="line">  async actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(&apos;gotData&apos;, await getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  async actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    await dispatch(&apos;actionA&apos;) // 等待 actionA 完成</span><br><span class="line">    commit(&apos;gotOtherData&apos;, await getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>由于 Vuex 使用<strong>单一状态树</strong>模式，来统一管理应用所有的状态，导致所有状态会集中到一个比较大的对象，随着后续不断得迭代，这个对象就会越来越庞大，后期的代码可读性、可维护性就会不断加大。<br>解决以上问题，就需要对这个对象的内部进行拆分和细分化，对状态进行分门别类，也就产生了<strong>模块（module）</strong> 这个概念。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割，将庞大的系统进行合理有效的职能划分，遵循单一职责的理念，每个模块清晰明了的自己的职责和职能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a // -&gt; moduleA 的状态</span><br><span class="line">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure><p>声明模块后，state、mutation、action、getter 等使用方式、作用和不在 <code>modules</code> 内声明方式基本一样，只是在细节上进行了一些细微的改变，比如： getter 里默认接收一个参数 state，模块里接收 state 就是本身模块自己的 state 状态了，而不是全局的了； 调用获取上也多一道需要告知那个模块获取状态 等一些细节上的差异。</p><h4 id="Module-里-state、mutation、action、getter-上的一些差异"><a href="#Module-里-state、mutation、action、getter-上的一些差异" class="headerlink" title="Module 里 state、mutation、action、getter 上的一些差异"></a>Module 里 state、mutation、action、getter 上的一些差异</h4><p>（1）模块内部的 mutation 和 getter，接收的第一个参数 <code>state</code> 是<strong>模块的局部状态对象</strong>。<br>（2）模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code><br>（3）模块内部的 getter，根节点状态会作为<strong>第三个参数</strong>暴露出来</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>默认情况下，模块内部的 action、mutation 和 getter 是<strong>注册在全局命名空间</strong>的——这样使得多个模块能够对同一 mutation 或 action 作出响应，所以必须防止模块里属性或方法重名。</p><p>为了模块具有更高的封装度、复用性和独立性，可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。在调用上也就需要添加上声明 getter、action 及 mutation 到底属于那个模块了，以路径的形式表示属于那个模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    account: &#123;</span><br><span class="line">      namespaced: true, // 开启命名空间</span><br><span class="line"></span><br><span class="line">      // 模块内容（module assets）</span><br><span class="line">      state: &#123; ... &#125;, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span><br><span class="line">      getters: &#123;</span><br><span class="line">        isAdmin () &#123; ... &#125; // -&gt; getters[&apos;account/isAdmin&apos;] 调用时以路径的形式表明归属</span><br><span class="line">      &#125;,</span><br><span class="line">      actions: &#123;</span><br><span class="line">        login () &#123; ... &#125; // -&gt; dispatch(&apos;account/login&apos;)</span><br><span class="line">      &#125;,</span><br><span class="line">      mutations: &#123;</span><br><span class="line">        login () &#123; ... &#125; // -&gt; commit(&apos;account/login&apos;)</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      // 嵌套模块</span><br><span class="line">      modules: &#123;</span><br><span class="line">        // 继承父模块的命名空间</span><br><span class="line">        myPage: &#123;</span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            profile () &#123; ... &#125; // -&gt; getters[&apos;account/profile&apos;]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 进一步嵌套命名空间</span><br><span class="line">        posts: &#123;</span><br><span class="line">          namespaced: true,</span><br><span class="line"></span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            popular () &#123; ... &#125; // -&gt; getters[&apos;account/posts/popular&apos;]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="在带命名空间的模块内访问全局内容"><a href="#在带命名空间的模块内访问全局内容" class="headerlink" title="在带命名空间的模块内访问全局内容"></a>在带命名空间的模块内访问全局内容</h4><p>带命名空间的模块内访问全局 state 、getter 和 action， <code>rootState</code>和 <code>rootGetter</code>会作为第三和第四参数传入 <code>getter</code>，也会通过 <code>context</code> 对象的属性传入 action。<br>需要在全局命名空间内分发 <code>action</code> 或提交 <code>mutation</code>，将 <code>{ root: true }</code> 作为第三参数传给 <code>dispatch</code> 或 <code>commit</code> 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">modules: &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    namespaced: true,</span><br><span class="line"></span><br><span class="line">    getters: &#123;</span><br><span class="line">      // 在这个模块的 getter 中，`getters` 被局部化了</span><br><span class="line">      // 全局的 state 和 getters 可以作为第三、四个参数进行传入，从而访问全局 state 和 getters</span><br><span class="line">      someGetter (state, getters, rootState, rootGetters) &#123;</span><br><span class="line">        getters.someOtherGetter // -&gt; &apos;foo/someOtherGetter&apos;</span><br><span class="line">        rootGetters.someOtherGetter // -&gt; &apos;someOtherGetter&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherGetter: state =&gt; &#123; ... &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    actions: &#123;</span><br><span class="line">      // 在这个模块中， dispatch 和 commit 也被局部化了</span><br><span class="line">      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span><br><span class="line">      someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;</span><br><span class="line">        getters.someGetter // -&gt; &apos;foo/someGetter&apos;</span><br><span class="line">        rootGetters.someGetter // -&gt; &apos;someGetter&apos;</span><br><span class="line"></span><br><span class="line">        dispatch(&apos;someOtherAction&apos;) // -&gt; &apos;foo/someOtherAction&apos;</span><br><span class="line">        dispatch(&apos;someOtherAction&apos;, null, &#123; root: true &#125;) // -&gt; &apos;someOtherAction&apos;</span><br><span class="line"></span><br><span class="line">        commit(&apos;someMutation&apos;) // -&gt; &apos;foo/someMutation&apos;</span><br><span class="line">        commit(&apos;someMutation&apos;, null, &#123; root: true &#125;) // -&gt; &apos;someMutation&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherAction (ctx, payload) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在带命名空间的模块注册全局-action"><a href="#在带命名空间的模块注册全局-action" class="headerlink" title="在带命名空间的模块注册全局 action"></a>在带命名空间的模块注册全局 action</h4><p>需要在带命名空间的模块注册全局 <code>action</code>，你可添加 <code>root: true</code>，并将这个 action 的定义放在函数 handler 中。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  actions: &#123;</span><br><span class="line">    someOtherAction (&#123;dispatch&#125;) &#123;</span><br><span class="line">      dispatch(&apos;someAction&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      namespaced: true,</span><br><span class="line"></span><br><span class="line">      actions: &#123;</span><br><span class="line">        someAction: &#123;</span><br><span class="line">          root: true,</span><br><span class="line">          handler (namespacedContext, payload) &#123; ... &#125; // -&gt; &apos;someAction&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="带命名空间的模块里辅助函数如何使用？"><a href="#带命名空间的模块里辅助函数如何使用？" class="headerlink" title="带命名空间的模块里辅助函数如何使用？"></a>带命名空间的模块里辅助函数如何使用？</h5><p>将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。</p><pre></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&apos;some/nested/module&apos;, &#123;</span><br><span class="line">    a: state =&gt; state.a,</span><br><span class="line">    b: state =&gt; state.b</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions(&apos;some/nested/module&apos;, [</span><br><span class="line">    &apos;foo&apos;,</span><br><span class="line">    &apos;bar&apos;</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以通过使用 <code>createNamespacedHelpers</code> 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createNamespacedHelpers &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">const &#123; mapState, mapActions &#125; = createNamespacedHelpers(&apos;some/nested/module&apos;)</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 在 `some/nested/module` 中查找</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      a: state =&gt; state.a,</span><br><span class="line">      b: state =&gt; state.b</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 在 `some/nested/module` 中查找</span><br><span class="line">    ...mapActions([</span><br><span class="line">      &apos;foo&apos;,</span><br><span class="line">      &apos;bar&apos;</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模块动态注册"><a href="#模块动态注册" class="headerlink" title="模块动态注册"></a>模块动态注册</h4><p>在 store 创建之后，你可以使用 <code>store.registerModule</code> 方法注册模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 注册模块 `myModule`</span><br><span class="line">store.registerModule(&apos;myModule&apos;, &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br><span class="line">// 注册嵌套模块 `nested/myModule`</span><br><span class="line">store.registerModule([&apos;nested&apos;, &apos;myModule&apos;], &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvuex-router-sync" target="_blank" rel="noopener">vuex-router-sync</a> 插件就是通过动态注册模块将 <code>vue-router</code> 和 <code>vuex</code> 结合在一起，实现应用的路由状态管理。</p><p>你也可以使用 <code>store.unregisterModule(moduleName)</code>来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）。</p><p>原文作者：Junting</p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2019/04/19/Vuex%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TypeScript</title>
      <link>https://github.com/wubianluoye/2019/02/20/TypeScript%E7%AE%80%E4%BB%8B/</link>
      <guid>https://github.com/wubianluoye/2019/02/20/TypeScript%E7%AE%80%E4%BB%8B/</guid>
      <pubDate>Wed, 20 Feb 2019 13:17:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;  &lt;strong&gt;TypeScript简介&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub 上。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  其次引用官网的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. Any browser. Any host. Any OS. Open source.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  翻译成中文即是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  &lt;strong&gt;为什么选择 TypeScript&lt;/strong&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>  <strong>TypeScript简介</strong></p><pre><code>TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub 上。</code></pre><p>  其次引用官网的定义：</p><pre><code>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. Any browser. Any host. Any OS. Open source.</code></pre><p>  翻译成中文即是：</p><pre><code>TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。</code></pre><p>  <strong>为什么选择 TypeScript</strong><br><a id="more"></a><br>    TypeScript 官网列举了一些优势，不过我更愿意自己总结一下：</p><pre><code>TypeScript 增加了代码的可读性和可维护性类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了可以在编译阶段就发现大部分错误，这总比在运行时候出错好增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等</code></pre><p>  <strong>TypeScript 非常包容</strong><br>    TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可<br>    即使不显式的定义类型，也能够自动做出类型推论<br>    可以定义从简单到复杂的几乎一切类型<br>    即使 TypeScript 编译报错，也可以生成 JavaScript 文件<br>    兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取</p><p>  <strong>TypeScript 拥有活跃的社区</strong><br>    大部分第三方库都有提供给 TypeScript 的类型定义文件<br>    Google 开发的 Angular2 就是使用 TypeScript 编写的<br>    TypeScript 拥抱了 ES6 规范，也支持部分 ESNext 草案的规范</p><p>  <strong>TypeScript 的缺点</strong><br>  任何事物都是有两面性的，我认为 TypeScript 的弊端在于：</p><pre><code>有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本集成到构建流程需要一些工作量可能和一些库结合的不是很完美</code></pre><p>  大家可以根据自己团队和项目的情况判断是否需要使用 TypeScript。</p><p>  <a href="https://ts.xcatliu.com/introduction/what-is-typescript.html" target="_blank" rel="noopener">TypeScript官网</a></p><p>  <a href="https://github.com/zhongsp/TypeScript">TypeScript中文手册</a></p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2019/02/20/TypeScript%E7%AE%80%E4%BB%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>假如测试说你的网站在iOS 10有问题</title>
      <link>https://github.com/wubianluoye/2018/02/08/%E5%81%87%E5%A6%82%E6%B5%8B%E8%AF%95%E8%AF%B4%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E5%9C%A8iOS-10%E6%9C%89%E9%97%AE%E9%A2%98/</link>
      <guid>https://github.com/wubianluoye/2018/02/08/%E5%81%87%E5%A6%82%E6%B5%8B%E8%AF%95%E8%AF%B4%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E5%9C%A8iOS-10%E6%9C%89%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Thu, 08 Feb 2018 03:43:28 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;strong&gt;这篇文章不那么有趣，只是解决了一个bug。但对我来讲，因为后面还要用Vue做很多项目，而且可以预见几乎每一个项目都会遇到这个问题，所以记录在案是有用的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个bug&lt;/p&gt;
&lt;p&gt;你用Vue做了一个单页面应用，它在一切设备上都工作正常，但是突然有一天，你的测试和你说，这个网站在iOS 10上跑不起来，怎么办？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>这篇文章不那么有趣，只是解决了一个bug。但对我来讲，因为后面还要用Vue做很多项目，而且可以预见几乎每一个项目都会遇到这个问题，所以记录在案是有用的。</strong></p><p>一个bug</p><p>你用Vue做了一个单页面应用，它在一切设备上都工作正常，但是突然有一天，你的测试和你说，这个网站在iOS 10上跑不起来，怎么办？</p><a id="more"></a><p>于是你打开你电脑上的Chrome浏览器，工作正常；打开Safari浏览器，工作正常；打开iOS 11手机，工作正常；打开各种安卓手机，工作正常。但是在iOS 10的手机上，不论是微信浏览器，还是Safari浏览器，都只能看见一个白白的屏幕。</p><p>于是你把手机连上电脑，在电脑端的Safari里，看到了如下的错误：</p><p>SyntaxError: Cannot declare a let variable twice: ‘e’.<br>可是你没有写过这样的代码，你怎么可能把一个名为e的变量定义两次？你打开代码，看到了这样美丽的代码：</p><pre><code>let e = e =&gt; {    console.log(e);    for (let e of [1, 2, 3])        console.log(e);};</code></pre><p>虽然这段代码看上去比较奇怪，但是语法上有任何问题吗？哥就愿意定义一个名为e的函数，而这个函数的唯一入参名称也为e，并且哥的for循环体里还愿意再定义一个名称为e的变量，es6的变量作用域允许我们这样做，此e和彼e互不干扰，不对吗？况且很显然，这段代码不是人写的，而是我们在执行npm run build的时候编译产生的。</p><p>其实我们都没有错，我们也没写错，uglify也没搞错，错的是Safari本身。他们在第十七万一千零四十一号bug中承认了自己的错误：</p><pre><code>We incorrectly throw a syntax error when declaring a top level for-loop iteration variable the same as a parameter</code></pre><p>当你定义一个与参数同名的for循环迭代变量时，我们错误地认为这是一个语法错误。<br>看，多么谦逊的态度。所以你也不用太纠结于一个白屏幕，只要找到解决方法就好了。方法其实很简单：</p><p>进入<strong>build</strong>文件夹；<br>找到<strong>webpack.prod.conf.js</strong>文件；<br>在<strong>UglifyPlugin</strong>的定义里添加关于<strong>mangle的选项</strong>，使它变成下面这个样子：</p><pre><code>new UglifyJsPlugin({  uglifyOptions: {    compress: {      warnings: false    },    mangle: {      safari10: true    }  },  sourceMap: config.build.productionSourceMap,  parallel: true}),</code></pre><p>然后这个世界就太平了。</p><p>为了避免所有这些不必要的麻烦，我给vue-cli提的一个PR已被接受，在工具里缺省加入了这个选项，这样大家以后就不会遇到这个问题了。</p><p>关于这个bug的问题描述在这里，解决方案在这里，给vue-cli提的PR在这里，供深挖细掘的人参考。</p><p>另一个bug</p><p>实际上，除此之外，还有另外一个bug也会影响到vue网页在iOS 10上的展现，特别是当你用到广为流传的Swiper插件的时候。这是因为Swiper插件中用到了ES6的语法a = b ** c，a是b的c次方，而iOS 10的Safari里不认识这样的语法，认为这是一个错误，所以你需要让Swiper经过babel的包装，而缺省状态下babel是不对node_modules里的模块进行编译的。相关的issue见这里。</p><p>解决方法是在项目根目录下新建一个文件vue.config.js，在里面添加如下语句：</p><pre><code>module.exports = {  chainWebpack: config =&gt; {    config.rule(&apos;js&apos;).include.add(/node_modules\/(dom7|swiper)\/.*/)  }}</code></pre><p>至止为止，通常情况下你的vue网页已经可以完美地在iOS 10上的Safari里展现了。</p><p><a href="https://segmentfault.com/a/1190000013075464" target="_blank" rel="noopener">原文链接</a></p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2018/02/08/%E5%81%87%E5%A6%82%E6%B5%8B%E8%AF%95%E8%AF%B4%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E5%9C%A8iOS-10%E6%9C%89%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>在微信、微博、QQ、Safari唤起App的解决方案</title>
      <link>https://github.com/wubianluoye/2018/01/25/%E5%9C%A8%E5%BE%AE%E4%BF%A1%E3%80%81%E5%BE%AE%E5%8D%9A%E3%80%81QQ%E3%80%81Safari%E5%94%A4%E8%B5%B7App%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <guid>https://github.com/wubianluoye/2018/01/25/%E5%9C%A8%E5%BE%AE%E4%BF%A1%E3%80%81%E5%BE%AE%E5%8D%9A%E3%80%81QQ%E3%80%81Safari%E5%94%A4%E8%B5%B7App%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <pubDate>Thu, 25 Jan 2018 10:11:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近在做微信、QQ、微博中使用js唤起App，之前也做过类似的功能，不过比较粗糙，考虑的情况不太全，而且那已经是很久之前的事情了，很多技术都已过时，现在有体验更好，功能更加完善的唤起技术，之前的很多的方案，到了现在都已是不太必要了，现在通过这篇文章分享给大家一个全面的、最新的唤起方案，希望对大家有帮忙。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近在做微信、QQ、微博中使用js唤起App，之前也做过类似的功能，不过比较粗糙，考虑的情况不太全，而且那已经是很久之前的事情了，很多技术都已过时，现在有体验更好，功能更加完善的唤起技术，之前的很多的方案，到了现在都已是不太必要了，现在通过这篇文章分享给大家一个全面的、最新的唤起方案，希望对大家有帮忙。</p><p><strong>目标</strong></p><a id="more"></a><p>用户点击打开App或者下载按钮（这个按钮可能在一个下载入口页、各种分享页面的吸顶或吸底的banner），如果用户已经安装了App，则根据业务跳转到相应的Native页面；如果用户没有安装该应用，则跳到AppStore或者应用市场去下载我们的App。</p><p><strong>一个完整的流程</strong></p><p>首先所有的下载/唤起入口都是一个直接跳转，应该是这样：</p><p>&lt;ahref=”<a href="https://applink-party.mtime.cn/mtlf&quot;&gt;下载" target="_blank" rel="noopener">https://applink-party.mtime.cn/mtlf&quot;&gt;下载</a><br>或者这样：</p><p>window.location.href = ‘<a href="https://applink-party.mtime.cn/mtlf&#39;" target="_blank" rel="noopener">https://applink-party.mtime.cn/mtlf&#39;</a><br>所有的业务判断都是mtlf这个页面里面来做，这样有两个好处：</p><ol><li>多业务共用代码。在一个团队中，每个人的业务都可能有一个banner下载，没有比location到一个url更简单的调用方式了</li><li>能够利用universal link</li></ol><p><strong>简单说下universal link</strong></p><p>在iOS9之前，唤起方式和现在安卓是一个的，都是使用scheme进行唤起，这种方式有个小问题，每次唤起，都会给个提示：是否打开xx应用，这样从体验上来讲，又让用户多一步操作。universal link会直接跳转，不会在页面做停留，条件就是在我们项目的根目录，增一个apple-app-site-association.json文件，里面的内容大致是这样：</p><p><img src="https://i.imgur.com/UYAcpX7.png" alt></p><p>然后iOS的App后台再配置一下，就可以实现直接唤起了！</p><p><strong>微信、微博、QQ、Safari在各平台的唤起方案</strong></p><p><img src="https://i.imgur.com/K8soWRi.png" alt></p><p>经过长时间的实验，总结了这张在各种情况下，唤起成功/唤起失败的解决方案，我们接下来一个一个的说。</p><p><strong>微信</strong></p><p>微信是最重要的一种分享渠道，但是我们能够做的，却不多。之前，iOS下的微信支持universal link这种唤起方式，但是从2018年1月8日之后，<strong>微信把这个给屏蔽了！！！</strong>不管微信基于什么原因，把iOS下这种最便捷的唤起方式屏蔽，我们能做的只能是适应了。so，现在不管是iOS还是android，我们的处理方式是一样的：<strong>都是直接跳到应用宝</strong>。iOS的应用宝会引导找开AppStore，android的应用宝会直接打开App（前提是你已经下载）<br>注：微信把itunes链接也屏蔽了，所以也没办法直接跳转AppStore，只能借助应用宝来搭这个桥。</p><p><strong>微博</strong></p><p>微博目前还支持universal link唤起，我们只需要考虑未下载的情况。</p><ul><li>在iOS下，微博是不支持打开应用宝的链接，所以我们需要引导用户使用Safari打开，像这样：</li></ul><p><img src="https://i.imgur.com/YuVx2NT.png" alt></p><ul><li>在android平台下，使用scheme这种方式是唤不起App的，但是有特例，同样是scheme，大人点评和网易云音乐就可以唤起，有空大家可以自己试试，所以我们可以推断出，安卓平台下的微博，也有类似微信一样的白名单，在白名单内的，就可以使用scheme唤起，就像微信之于京东，京东在微信里面就是通过scheme方式唤起的。</li></ul><p>so，不管是iOS还是android，我们的方案是：直接引导用户使用本地浏览器打开。</p><p><strong>QQ</strong></p><ul><li>iOS平台下，QQ目前还支持universal link唤起，要是没有安装，QQ下也支持直接打开itunes链接，比较其他应用，QQ支持是最好的。</li><li>android平台下，QQ也支持scheme方式唤起，但是在一些老机型下，QQ会有一定的概率唤起失败，具体的现象是：第一次打开页面，唤起失败，再次打开，唤起成功。根据现象，我们可以推测出，在QQ的webview中，会对scheme的唤起方式做一些加载时间上的限制，经测试，大约在500ms，超过这个时间值，就会出现唤起失败的情况。为什么第二次打开，唤起成功的概率会大，是因为第一次加载时，已缓存了文件，第二次打开直接加载，这样时间在限制之内。</li></ul><p><strong>Safari</strong></p><p>Safari这种情况比较简单，支持universal link，也支持直接打开itunes，so，如图处理就可以了。</p><p><strong>踩坑</strong></p><p>H2M_LI_HEADER</p><ul><li>在iOS9中，Safari不支持直接跳转itunes，so，这种情况需要做兼容处理，可以直接跳到应用宝</li><li>之前看唤起是不是成功了，需要自己来计算时间，因为要是唤起成功了，setInterval的时间就会变慢，经我测试，已经用不到这种方法了，只需要使用document.hidden || document.webkitHidden就可以，兼容性还不错</li><li><p>判断是不是Safari浏览器时，一般判断都是UA中有没有这个字符串，经测试发现，安卓的UA中，也包含Safari这个字符串（如下UA展示），所以需要加上操作系统的判断</p></li><li><p>关于Scheme唤起，之前有很多方案，</p></li><li>比如：使用iframe、<a>标签点击、window.location…经测试，只要使用a标签点击，这样兼容性最好，代码大约长这样：</a></li></ul><p><img src="https://i.imgur.com/RXwBI0p.png" alt></p><p><strong>关于测试</strong></p><p>两个平台，这么多情况，要一个一个测试吗？当然要一个一个的验证，但是在开发期间，没有必要改一行，在手机上测试一下，这样效率太低了，尤其是像一样，选了一个安卓4.4的手机，绝对可以磨练你的耐心。为了提高效率，我把我常用到的UA分享给大家，这样在Chrome模拟器里配置一下，就可以本地调试了，常用UA如下：</p><ul><li>iOS-微信</li></ul><p>Mozilla/5.0 (iPhone; CPU iPhone OS 11_2_2 like Mac OS X) AppleWebKit/604.4.7 (KHTML, like Gecko) Mobile/15C202 MicroMessenger/6.6.1 NetType/WIFI Language/zh_CN</p><ul><li>iOS-QQ</li></ul><p>Mozilla/5.0 (iPhone; CPU iPhone OS 11_2_2 like Mac OS X) AppleWebKit/604.4.7 (KHTML, like Gecko) Mobile/15C202 QQ/7.3.5.473 V1_IPH_SQ_7.3.5_1_APP_A Pixel/1125 Core/UIWebView Device/Apple(iPhone X) NetType/WIFI QBWebViewType/1</p><ul><li>iOS-微博</li></ul><p>Mozilla/5.0 (iPhone; CPU iPhone OS 11_2_2 like Mac OS X) AppleWebKit/604.4.7 (KHTML, like Gecko) Mobile/15C202 Weibo (iPhone10,3__weibo__8.1.0__iphone__os11.2.2)</p><ul><li>iOS-safari</li></ul><p>Mozilla/5.0 (iPhone; CPU iPhone OS 11_2_2 like Mac OS X) AppleWebKit/604.4.7 (KHTML, like Gecko) Version/11.0 Mobile/15C202 Safari/604.1</p><ul><li>android-微信</li></ul><p>Mozilla/5.0 (Linux; Android 4.4.2; PE-TL20 Build/HuaweiPE-TL20; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/57.0.2987.132 MQQBrowser/6.2 TBS/043807 Mobile Safari/537.36 MicroMessenger/6.6.1.1220(0x26060135) NetType/WIFI Language/zh_CN</p><ul><li>android-QQ</li></ul><p>Mozilla/5.0 (Linux; Android 4.4.2; PE-TL20 Build/HuaweiPE-TL20; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/57.0.2987.132 MQQBrowser/6.2 TBS/043807 Mobile Safari/537.36 V1_AND_SQ_7.3.2_762_YYB_D QQ/7.3.2.3350 NetType/WIFI WebP/0.3.0 Pixel/1080</p><ul><li>android-微博</li></ul><p>Mozilla/5.0 (Linux; Android 4.4.2; PE-TL20 Build/HuaweiPE-TL20) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/30.0.0.0 Mobile Safari/537.36 Weibo (HUAWEI-PE-TL20__weibo__8.0.2__android__android4.4.2)</p><p>配置完成之后，就可以像我一样，在电脑上切换环境啦：</p><p>源代码以及库文件使用，请参见：<a href="https://github.com/sunhaikuo/js-arouse-app">https://github.com/sunhaikuo/js-arouse-app</a></p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2018/01/25/%E5%9C%A8%E5%BE%AE%E4%BF%A1%E3%80%81%E5%BE%AE%E5%8D%9A%E3%80%81QQ%E3%80%81Safari%E5%94%A4%E8%B5%B7App%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
