<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>wubianluoye</title>
    <link>https://github.com/wubianluoye/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="%5Bobject%20Object%5D" rel="hub"/>
    <description></description>
    <pubDate>Sat, 09 May 2020 13:23:12 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>函数和变量声明提前与执行上下文</title>
      <link>https://github.com/wubianluoye/2020/05/09/%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%89%8D%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</link>
      <guid>https://github.com/wubianluoye/2020/05/09/%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%89%8D%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</guid>
      <pubDate>Sat, 09 May 2020 13:00:00 GMT</pubDate>
      <description>
      
        &lt;h5 id=&quot;一、-——————&quot;&gt;&lt;a href=&quot;#一、-——————&quot; class=&quot;headerlink&quot; title=&quot;一、 ——————&quot;&gt;&lt;/a&gt;一、 ——————&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;console.log(bar); // ???&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var bar = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function bar()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&amp;quot;bar&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 结果： Function&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h5 id="一、-——————"><a href="#一、-——————" class="headerlink" title="一、 ——————"></a>一、 ——————</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(bar); // ???</span><br><span class="line">var bar = 1;</span><br><span class="line">function bar()&#123;</span><br><span class="line">  console.log(&quot;bar&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结果： Function</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">伪代码</span><br><span class="line">1.声明阶段</span><br><span class="line">function bar</span><br><span class="line">var bar</span><br><span class="line">2.执行阶段</span><br><span class="line">console.log(bar) // fn</span><br><span class="line">bar=1</span><br><span class="line">从上往下顺序执行</span><br></pre></td></tr></table></figure><h5 id="二、-——————"><a href="#二、-——————" class="headerlink" title="二、 ——————"></a>二、 ——————</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(foo); // ???</span><br><span class="line">var foo = 1;</span><br><span class="line">console.log(foo); // ???</span><br><span class="line">function foo()&#123;</span><br><span class="line">    console.log(&quot;foo&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 结果： Function,1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">伪代码</span><br><span class="line">1.声明阶段</span><br><span class="line">function foo</span><br><span class="line">var foo</span><br><span class="line">2.执行阶段</span><br><span class="line">console.log(foo) //fn</span><br><span class="line">foo=1</span><br><span class="line">console.log(foo) // 1</span><br><span class="line">从上往下顺序执行</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var bbz=1</span><br><span class="line">function bbz ()&#123;&#125;</span><br><span class="line">console.log(bbz)</span><br><span class="line">bbz=100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// function bbz</span><br><span class="line">// bbz</span><br><span class="line">// bbz=1</span><br><span class="line">// console.log(bbz)</span><br><span class="line">// bbz=100</span><br></pre></td></tr></table></figure><h5 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h5><p>一个执行上下文的生命周期可以分为两个阶段:<br>1、声明<br>2、执行</p><blockquote><p>js从上往下执行，首先会处理函数声明，其次会处理变量声明。<br>在执行阶段时，后面的赋值将覆盖掉前面的function。</p></blockquote><h3 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h3><p><a href="https://github.com/mqyqingfeng/Blog/issues/5">冴羽-JavaScript深入之变量对象</a></p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2020/05/09/%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%89%8D%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/#disqus_thread</comments>
    </item>
    
    <item>
      <title>express摸文档之路</title>
      <link>https://github.com/wubianluoye/2020/03/28/express/</link>
      <guid>https://github.com/wubianluoye/2020/03/28/express/</guid>
      <pubDate>Sat, 28 Mar 2020 09:20:20 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;一、静态目录设置&quot;&gt;&lt;a href=&quot;#一、静态目录设置&quot; class=&quot;headerlink&quot; title=&quot;一、静态目录设置&quot;&gt;&lt;/a&gt;一、静态目录设置&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;nodejs中没有像apache等的提供静态文件夹，需要自己设置。&lt;/li&gt;
&lt;li&gt;静态文件夹也可以设置多个，只需要app.use()多个即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const express = require(&amp;apos;epxress&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const app = express()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app.use(&amp;apos;/static&amp;apos;,express.static(__dirname+&amp;apos;/public&amp;apos;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// &amp;apos;/static&amp;apos; 则localhose:3000/static访问到静态文件夹位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 也可以不写，则默认访问根目录时，都能访问到静态文件夹位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// static(__dirname+&amp;apos;/public&amp;apos;)) // &amp;apos;/public&amp;apos;为本地的需要作为静态文件夹的目录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="一、静态目录设置"><a href="#一、静态目录设置" class="headerlink" title="一、静态目录设置"></a>一、静态目录设置</h3><ul><li>nodejs中没有像apache等的提供静态文件夹，需要自己设置。</li><li>静态文件夹也可以设置多个，只需要app.use()多个即可。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;epxress&apos;)</span><br><span class="line">const app = express()</span><br><span class="line">app.use(&apos;/static&apos;,express.static(__dirname+&apos;/public&apos;))</span><br><span class="line"></span><br><span class="line">// &apos;/static&apos; 则localhose:3000/static访问到静态文件夹位置</span><br><span class="line">// 也可以不写，则默认访问根目录时，都能访问到静态文件夹位置</span><br><span class="line">// static(__dirname+&apos;/public&apos;)) // &apos;/public&apos;为本地的需要作为静态文件夹的目录</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="二、req属性"><a href="#二、req属性" class="headerlink" title="二、req属性"></a>二、req属性</h3><ul><li><p>当req是 <em>post</em> 请求时，获取参数需要用到插件<code>body-parser</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">npm install body-parser</span><br><span class="line"></span><br><span class="line">const bodyParser = require(&apos;body-parser&apos;)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended: false&#125;))</span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line"></span><br><span class="line">app.post(&apos;/home&apos;, (req, res) =&gt; &#123;</span><br><span class="line">console.log(req.body) // 获取到传回来的参数（json格式）</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>req.hostname 从请求头获取主机</p></li><li><p>req.query,当请求如’localhost:3000/user?id=9&amp;name=xiaoming’时，可以通过req.query获取到参数，并且自动转为json格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">id: 9,</span><br><span class="line">name: &apos;xiaoming&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>req.params,当请求如’localhost:3000/user/9’时，可以通过req.params获取到参数，并且自动转为json格式。<br>也可以获取多个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 单个参数时 localhost:3000/user/9</span><br><span class="line">// 对应app.post(&apos;/user/:id&apos;)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">id: 9</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多个参数时 localhost:3000/user/9/abc</span><br><span class="line">// 对应app.post(&apos;/user/:id/:name&apos;)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">id: 9,</span><br><span class="line">name: &apos;abc&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>req.path 获取请求URL</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// example.com/users?sort=desc</span><br><span class="line">console.log(req.path)</span><br><span class="line">// =&gt; &apos;/users&apos;</span><br></pre></td></tr></table></figure><ul><li>req.route 获取当前路由的路由信息</li></ul><h3 id="三、res属性"><a href="#三、res属性" class="headerlink" title="三、res属性"></a>三、res属性</h3><ul><li><p>res.append, 可以用来设置响应头参数 <code>res.append(field [, value])</code><br><code>res.append(&#39;Set-Cookie&#39;, &#39;foo=bar; Path=/; HttpOnly&#39;)</code></p></li><li><p>res.cookie, 设置响应头cookie参数 <code>res.cookie(name, value [, options])</code><br><code>res.cookie(&#39;name&#39;, &#39;tobi&#39;, { domain: &#39;.example.com&#39;, path: &#39;/admin&#39;, secure: true })</code></p></li><li><p>res.json(obj),可以将数据以json格式返回，但也得传的是json格式</p></li><li><p>res.render(), 可以渲染一个文件到浏览器 <code>res.render(view [, locals] [, callback])</code></p></li><li>res.download(file) 访问时，浏览器自动下载文件</li><li>res.type 设置mime类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.type(&apos;.html&apos;)</span><br><span class="line">// =&gt; &apos;text/html&apos;</span><br></pre></td></tr></table></figure></li></ul><h3 id="三、router"><a href="#三、router" class="headerlink" title="三、router"></a>三、router</h3><ul><li><p>通过<code>const router = express.Router()</code>来获取router，再通过router.get或router.post等方式设置路由路径。<br>它可以接收3个参数(req,res,next),其中，前2两个与上面一样，next可以用来处理一些其他状态，<br>但是需要注意的是，若参数中有加next，那么在最后必须加上next(),不然路由无法继续。<br>一般用来做中间件过滤器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line"></span><br><span class="line">router.get(&apos;/name&apos;, (req, res, next) =&gt; &#123;</span><br><span class="line">console.log(req.path)</span><br><span class="line">res.send(&apos;user: &apos;+req.params.id)</span><br><span class="line">// do things</span><br><span class="line">next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>引用router时，通过app.use(require(‘/router/index.js’))<br>这时，访问localhost:3000/name时，路由会自定去找到index.js中的/name路径。</p></li></ul><p>也可写成这样app.use(‘/user’,require(‘/router/index.js’))<br>那么就需要访问localhost:3000/user/name才能定位到它了。</p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2020/03/28/express/#disqus_thread</comments>
    </item>
    
    <item>
      <title>vue项目在同一局域网移动端无法打开解决方法</title>
      <link>https://github.com/wubianluoye/2020/03/20/vue%E9%A1%B9%E7%9B%AE%E5%9C%A8%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <guid>https://github.com/wubianluoye/2020/03/20/vue%E9%A1%B9%E7%9B%AE%E5%9C%A8%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <pubDate>Fri, 20 Mar 2020 12:12:47 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;当局域网内手机访问电脑本地webpack服务器被拒绝时，在webpack.config.js的&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>当局域网内手机访问电脑本地webpack服务器被拒绝时，在webpack.config.js的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  host: &apos;0.0.0.0&apos;, // 增加这一行</span><br><span class="line">  useLocalIp: true, // 增加这一行</span><br><span class="line">  disableHostCheck: true, // 增加这一行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过cmd ipconfig 获取到本地ipv4地址 如： 192.168.95.21<br>再拼上端口号就行了</p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2020/03/20/vue%E9%A1%B9%E7%9B%AE%E5%9C%A8%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>移动端将手机输入法中的完成变成搜索功能实现</title>
      <link>https://github.com/wubianluoye/2020/03/20/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B0%86%E6%89%8B%E6%9C%BA%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%AD%E7%9A%84%E5%AE%8C%E6%88%90%E5%8F%98%E6%88%90%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</link>
      <guid>https://github.com/wubianluoye/2020/03/20/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B0%86%E6%89%8B%E6%9C%BA%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%AD%E7%9A%84%E5%AE%8C%E6%88%90%E5%8F%98%E6%88%90%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Fri, 20 Mar 2020 12:11:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;当我们的移动端想实现如淘宝搜索页面，虚拟键盘有个搜索按钮时。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;原生版&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;form id=&amp;quot;myform&amp;quot; action=&amp;quot;javascript:;&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;input type=&amp;quot;search&amp;quot; id=&amp;quot;search&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>当我们的移动端想实现如淘宝搜索页面，虚拟键盘有个搜索按钮时。</p><p><code>原生版</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;form id=&quot;myform&quot; action=&quot;javascript:;&quot;&gt;</span><br><span class="line">&lt;input type=&quot;search&quot; id=&quot;search&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;search&apos;).onkeyup = function(event) &#123;</span><br><span class="line">if(event.keyCode === 13) &#123;</span><br><span class="line">document.getElementById(&apos;search&apos;).blur();</span><br><span class="line">// doth</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vue版</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;form action=&quot;javascript:;&quot;&gt;</span><br><span class="line">&lt;input v-model=&quot;value&quot; @keyup.enter=&quot;search&quot; ref=&quot;search&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">search() &#123;</span><br><span class="line">this.$refs.search.blur()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，需要一个form表单包住我们的搜索框，并禁止表单提交；<br>然后，将input的type设置为search。 然后会发现点击搜索后，虚拟键盘不会自动收回;<br>所以，还需要添加一个点击了搜索按钮后，关闭虚拟按键。也就是让input失去焦点。</p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2020/03/20/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B0%86%E6%89%8B%E6%9C%BA%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%AD%E7%9A%84%E5%AE%8C%E6%88%90%E5%8F%98%E6%88%90%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Pormise与Async/Await</title>
      <link>https://github.com/wubianluoye/2020/01/11/Promise%E5%92%8CAsync%E3%80%81Await/</link>
      <guid>https://github.com/wubianluoye/2020/01/11/Promise%E5%92%8CAsync%E3%80%81Await/</guid>
      <pubDate>Sat, 11 Jan 2020 02:10:00 GMT</pubDate>
      <description>
      
        &lt;pre&gt;&lt;code&gt;#### SECTION 1  promise
// 1.通过新建一个promise来进行异步，将等待上一个then执行完才会继续执行下一个then。执行时长为所有then的总和。(5000+2000 = 7000毫秒)
// 2.若new Promise()返还的时reject时，直接执行catch
&lt;/code&gt;&lt;/pre&gt;
      
      </description>
      
      <content:encoded><![CDATA[<pre><code>#### SECTION 1  promise// 1.通过新建一个promise来进行异步，将等待上一个then执行完才会继续执行下一个then。执行时长为所有then的总和。(5000+2000 = 7000毫秒)// 2.若new Promise()返还的时reject时，直接执行catch</code></pre><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let myPormise = new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">let start = new Date().getTime()</span><br><span class="line">let obj = &#123;</span><br><span class="line">result: 10,</span><br><span class="line">start: start</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(() =&gt; &#123; resolve(obj) &#125;, 5000)</span><br><span class="line">//reject(&apos;error&apos;) 错误只能在刚开始时返回？？？</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">myPormise.then((res,s) =&gt; &#123;</span><br><span class="line">return new Promise((r,j) =&gt; &#123;</span><br><span class="line">res.result = 20 + res.result</span><br><span class="line">setTimeout(() =&gt; &#123; r(res) &#125;, 2000)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">let end = new Date().getTime()</span><br><span class="line">console.log(res.result)</span><br><span class="line">console.log(&apos;1,times &apos;+ (end - res.start) / 1000 + &apos;s!&apos;)</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">console.log(&apos;errortest&apos;, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><pre><code>#### SECTION 2  promise并发// 1.可以通过promise.all()方法来进行并发操作，用时则为当前最大延时(3000毫秒)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function f1(r) &#123;</span><br><span class="line">return new Promise((res, rej) =&gt; &#123;</span><br><span class="line">setTimeout(() =&gt; &#123; res(r) &#125;, 2000)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f2(r) &#123;</span><br><span class="line">return new Promise((res, rej) =&gt; &#123;</span><br><span class="line">setTimeout(() =&gt; &#123; res(r) &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f3(r) &#123;</span><br><span class="line">return new Promise((res, rej) =&gt; &#123;</span><br><span class="line">setTimeout(() =&gt; &#123; res(r) &#125;, 3000)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function alldone() &#123;</span><br><span class="line">let start = new Date().getTime()</span><br><span class="line">Promise.all([f1(100), f2(200), f3(300)]).then(res =&gt; &#123;</span><br><span class="line">console.log(res.reduce((cur, pre) =&gt; cur + pre, 0))</span><br><span class="line">let end = new Date().getTime()</span><br><span class="line">console.log(&apos;2,done, times: &apos;+ (end - start) / 1000+ &apos;s&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">alldone()</span><br></pre></td></tr></table></figure></code></pre><hr><pre><code>#### SECTION 3  async/await// 用时为(2000+4000 毫秒)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function syncfun(r) &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">setTimeout(() =&gt; &#123; resolve(r) &#125;, 2000)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function syf(r) &#123;</span><br><span class="line">return new Promise((res, rej) =&gt; &#123;</span><br><span class="line">setTimeout(() =&gt; &#123; res(r) &#125;, 4000)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function resut () &#123;</span><br><span class="line">try&#123;</span><br><span class="line">let start = new Date().getTime()</span><br><span class="line">let a = await syncfun(100)</span><br><span class="line">let b = await syf(200)</span><br><span class="line">let end = new Date().getTime()</span><br><span class="line">console.log(a + b)</span><br><span class="line">console.log(&apos;3,use times: &apos;+(end - start) / 1000 + &apos; seconds&apos;)</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">console.log(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">resut()</span><br></pre></td></tr></table></figure><hr><pre><code>#### SECTION 4  async/await+promise.all 并发// 用时为最大延时(4000毫秒)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">async function bresult() &#123;</span><br><span class="line">let start = new Date().getTime()</span><br><span class="line">let [a, b] = await Promise.all([syncfun(100), syf(200)])</span><br><span class="line">let end = new Date().getTime()</span><br><span class="line">console.log(a + b)</span><br><span class="line">console.log(&apos;4,use times: &apos;+(end - start) / 1000 + &apos; seconds&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bresult()</span><br></pre></td></tr></table></figure><p>// promise 7.002s  // 依次<br>// pormise.all 3.004s  // 并发<br>// async/await  6.004s  // 依次<br>// async/await + promise.all  4.004s  // 并发</p><hr><p>// 推荐文章：</p><p><a href="https://segmentfault.com/a/1190000011526612" target="_blank" rel="noopener">掘金：ES6系列文章 异步神器async-await</a></p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2020/01/11/Promise%E5%92%8CAsync%E3%80%81Await/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
