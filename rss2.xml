<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>wubianluoye</title>
    <link>https://github.com/wubianluoye/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="%5Bobject%20Object%5D" rel="hub"/>
    <description></description>
    <pubDate>Mon, 11 Dec 2017 08:49:09 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>vue项目在同一局域网无法打开解决方法</title>
      <link>https://github.com/wubianluoye/2017/12/11/vue%E9%A1%B9%E7%9B%AE%E5%9C%A8%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <guid>https://github.com/wubianluoye/2017/12/11/vue%E9%A1%B9%E7%9B%AE%E5%9C%A8%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <pubDate>Mon, 11 Dec 2017 08:35:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在使用vue-cli生成的vue文件想在手机上查看时，发现无法打开。（已将locahost：8080/替换成本机地址192.168.190.225：8080）&lt;/li&gt;
&lt;li&gt;已将node.js从防火墙中打勾。&lt;br&gt;问题还是一样，手机上无法打开。&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>问题：</strong></p><ol><li>在使用vue-cli生成的vue文件想在手机上查看时，发现无法打开。（已将locahost：8080/替换成本机地址192.168.190.225：8080）</li><li>已将node.js从防火墙中打勾。<br>问题还是一样，手机上无法打开。</li></ol><a id="more"></a><p><strong>解决方案：</strong></p><p>  <strong>找到vue项目的package.json文件</strong>，</p><p><strong>修改前</strong></p><pre><code>&quot;scripts&quot;: {    &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,    &quot;start&quot;: &quot;npm run dev&quot;,    &quot;unit&quot;: &quot;jest --config test/unit/jest.conf.js --coverage&quot;,    &quot;e2e&quot;: &quot;node test/e2e/runner.js&quot;,    &quot;test&quot;: &quot;npm run unit &amp;&amp; npm run e2e&quot;,    &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit/specs test/e2e/specs&quot;,    &quot;build&quot;: &quot;node build/build.js&quot;  },</code></pre><p>在”dev”: “webpack-dev-server –inline –progress –config build/webpack.dev.conf.js”</p><p>中添加 –host 192.168.190.225（注192.168.190.225改为你的本机地址），保存即可。</p><p><strong>修改后</strong></p><pre><code>&quot;scripts&quot;: {    &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js --host 192.168.190.225&quot;,    &quot;start&quot;: &quot;npm run dev&quot;,    &quot;unit&quot;: &quot;jest --config test/unit/jest.conf.js --coverage&quot;,    &quot;e2e&quot;: &quot;node test/e2e/runner.js&quot;,    &quot;test&quot;: &quot;npm run unit &amp;&amp; npm run e2e&quot;,    &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit/specs test/e2e/specs&quot;,    &quot;build&quot;: &quot;node build/build.js&quot;  },</code></pre>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/11/vue%E9%A1%B9%E7%9B%AE%E5%9C%A8%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>git删除远程分支</title>
      <link>https://github.com/wubianluoye/2017/12/11/git%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/</link>
      <guid>https://github.com/wubianluoye/2017/12/11/git%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/</guid>
      <pubDate>Mon, 11 Dec 2017 08:31:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;git branch -a   查看远程分支有哪些&lt;/p&gt;
&lt;p&gt;git checkout 分支名  切换到该分支&lt;/p&gt;
&lt;p&gt;git push origin –delete &lt;branchname&gt;  删除远程分支 &lt;/branchname&gt;&lt;/p&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<p>git branch -a   查看远程分支有哪些</p><p>git checkout 分支名  切换到该分支</p><p>git push origin –delete <branchname>  删除远程分支 </branchname></p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/11/git%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>vue项目中的跨域</title>
      <link>https://github.com/wubianluoye/2017/12/07/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E8%B7%A8%E5%9F%9F/</link>
      <guid>https://github.com/wubianluoye/2017/12/07/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E8%B7%A8%E5%9F%9F/</guid>
      <pubDate>Thu, 07 Dec 2017 06:47:32 GMT</pubDate>
      <description>
      
        &lt;p&gt;在写一些demo时，往往会借用别人的api，但是会有一个问题：有的api会有跨域问题，有的没有。那么，在有跨域问题时，我们使用&lt;br&gt;的axios是没法跨域的。所以…网上找了一波。&lt;/p&gt;
&lt;p&gt;发现了可以使用jsonp这个轮子来用用。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在写一些demo时，往往会借用别人的api，但是会有一个问题：有的api会有跨域问题，有的没有。那么，在有跨域问题时，我们使用<br>的axios是没法跨域的。所以…网上找了一波。</p><p>发现了可以使用jsonp这个轮子来用用。</p><a id="more"></a><pre><code>npm install jsonp --save &amp;&amp; cnpm install jsonp --save</code></pre><p>在需要的页面引入它就行了</p><pre><code>import jsonp from &apos;jsonp&apos;</code></pre><p>在axios的github中也有一个关于这个jsonp库的说明<a href="https://github.com/axios/axios/blob/master/COOKBOOK.md">文档</a></p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/07/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E8%B7%A8%E5%9F%9F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>react与redux,dva</title>
      <link>https://github.com/wubianluoye/2017/12/05/react%E4%B8%8Eredux-dva/</link>
      <guid>https://github.com/wubianluoye/2017/12/05/react%E4%B8%8Eredux-dva/</guid>
      <pubDate>Tue, 05 Dec 2017 03:55:38 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;strong&gt;一.  State和 Props&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  state是状态机。&lt;/p&gt;
&lt;p&gt;  应该包括：那些可能被组件的事件处理器改变并触发用户界面更新的数据，譬如需要对用户输入,服务器请求或者时间变化等作出响应。&lt;/p&gt;
&lt;p&gt;  不应该包括：计算所得数据、React组件（在render()里使用props和state来创建它）、基于props的重复数据（尽可能保持用props来做作为唯一的数据来源，把props保存到state中的有效的场景是需要知道它以前的值得时候,因为未来的props可能会变化）。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>一.  State和 Props</strong></p><p>  state是状态机。</p><p>  应该包括：那些可能被组件的事件处理器改变并触发用户界面更新的数据，譬如需要对用户输入,服务器请求或者时间变化等作出响应。</p><p>  不应该包括：计算所得数据、React组件（在render()里使用props和state来创建它）、基于props的重复数据（尽可能保持用props来做作为唯一的数据来源，把props保存到state中的有效的场景是需要知道它以前的值得时候,因为未来的props可能会变化）。</p><a id="more"></a><p>  props： 父级向子级传递数据的方式。</p><p><strong>二.  有状态组件和无状态组件（纯函数组件）</strong></p><p>  有状态组件</p><p>  通过React.createClass或者es6的class继承React.Component创建的组件。特性：具备完整的生命周期及实例化过程、支持this及ref指向。</p><p>  无状态组件：</p><p>  即stateless component( pure function Component)。以函数返回值方式方式创建的组件。特点： 无实例化过程及生命周期、无this及ref指向、函数接受props及context两个参数。</p><p>  实践模式</p><p>  创建多个只负责渲染数据的无状态(stateless)组件,在他们的上层创建一个有状态(stateful)组件并把它的状态通过props传给子级。有状态的组件封装了所有的用户交互逻辑，state中处理状态的变化, 而这些无状态组件只负责声明式地渲染数据.</p><p><strong>三.  受控组件、非受控组件及混合组件</strong></p><p>  有许多的web组件可以被用户的交互发生改变，比如：<code>&lt;input&gt;，&lt;select&gt;</code>。这些组件可以通过输入一些内容或者设置元素的value属性来改变组件的值。但是，因为React是单向数据流绑定的，这些组件可能会变得失控：</p><p>  1.一个维护它自己state里的value值的<code>&lt;Input&gt;</code>组件无法从外部被修改</p><p>  2.一个通过props来设置value值的<code>&lt;Input&gt;</code>组件只能通过外部控制来更新。</p><p>  受控组件：</p><p>  一个受控的<code>&lt;input&gt;</code>应该有一个value属性。渲染一个受控的组件会展示出value属性的值。 </p><p>  一个受控的组件不会维护它自己内部的状态，组件的渲染单纯的依赖于props。也就是说，如果我们有一个通过props来设置value的<code>&lt;input&gt;</code>组件，不管你如何输入，它都只会显示props.value。换句话说，你的组件是只读的。</p><p>  在处理一个受控组件的时候，应该始终传一个value属性进去，并且注册一个onChange的回调函数让组件变得可变。</p><p>  非受控组件</p><p>  一个没有value属性的<code>&lt;Input&gt;</code>就是一个非受控组件。通过渲染的元素，任意的用户输入都会被立即反映出来。非受控的<code>&lt;Input&gt;</code>只能通过OnChange函数来向上层通知自己被用户输入的更改。</p><p>  混合组件</p><p>  同时维护props.value和state.value的值。props.value在展示上拥有更高的优先级，state.value代表着组件真正的值。</p><p>  目的：</p><p>  1、支持传入值； </p><p>  2、可控：组件外部修改props可改变input组件的真实值及显示值； </p><p>  3、非可控：输入框中输入值，可同时改变input组件的真实值及显示值。</p><p><strong>四.  redux和dva</strong></p><p>  Redux</p><ol><li><p>Actions、Reducers 和 Store</p><p>action 可以理解为应用向 store 传递的数据信息（一般为用户交互信息）。在实际应用中，传递的信息可以约定一个固定的数据格式，比如: Flux Standard Action。 dispatch(action) 是一个同步的过程：执行 reducer 更新 state -&gt; 调用 store 的监听处理函数。如果需要在 dispatch 时执行一些异步操作（fetch action data），可以通过引入 Middleware 解决。</p><p>reducer 实际上就是一个函数：(previousState, action) =&gt; newState。用来执行根据指定 action 来更新 state 的逻辑。reducer 不存储 state, reducer 函数逻辑中不应该直接改变 state 对象, 而是返回新的 state 对象。</p><p>store 是一个单一对象，redux中只有唯一一个store实例。主要作用：</p><ol><li>管理应用的 state</li><li>通过 store.getState() 可以获取 state</li><li>通过 store.dispatch(action) 来触发 state 更新</li><li>通过 store.subscribe(listener) 来注册 state 变化监听器</li></ol></li></ol><ol><li>Dva</li></ol><p>数据流向</p><p>数据的改变发生通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，当此类行为会改变数据的时候可以通过 dispatch 发起一个 action，如果是同步行为会直接通过 Reducers 改变 State ，如果是异步行为（副作用）会先触发 Effects 然后流向 Reducers 最终改变 State，所以在 dva 中，数据流向非常清晰简明，并且思路基本跟开源社区保持一致（也是来自于开源社区）。</p><p>Modele</p><p>State</p><p>type State = any</p><p>State 表示 Model 的状态数据，通常表现为一个 javascript 对象（当然它可以是任何值）；操作的时候每次都要当作不可变数据（immutable data）来对待，保证每次都是全新对象，没有引用关系，这样才能保证 State 的独立性，便于测试和追踪变化。<br>在 dva 中你可以通过 dva 的实例属性 _store 看到顶部的 state 数据，但是通常你很少会用到:<br>    const app = dva();<br>    console.log(app._store); // 顶部的 state 数据</p><p>Action</p><p>type AsyncAction = any</p><p>Action 是一个普通 javascript 对象，它是改变 State 的唯一途径。无论是从 UI 事件、网络回调，还是 WebSocket 等数据源所获得的数据，最终都会通过 dispatch 函数调用一个 action，从而改变对应的数据。action 必须带有 type 属性指明具体的行为，其它字段可以自定义，如果要发起一个 action 需要使用 dispatch 函数；需要注意的是 dispatch 是在组件 connect Models以后，通过 props 传入的。</p><pre><code>dispatch({  type: &apos;add&apos;,});</code></pre><p>dispatch 函数</p><p>type dispatch = (a: Action) =&gt; Action</p><p>dispatching function 是一个用于触发 action 的函数，action 是改变 State 的唯一途径，但是它只描述了一个行为，而 dipatch 可以看作是触发这个行为的方式，而 Reducer 则是描述如何改变数据的。<br>在 dva 中，connect Model 的组件通过 props 可以访问到 dispatch，可以调用 Model 中的 Reducer 或者 Effects，常见的形式如：</p><pre><code>dispatch({  type: &apos;user/add&apos;, // 如果在 model 外调用，需要添加 namespace  payload: {}, // 需要传递的信息    });</code></pre><p>Reducer</p><p>type Reducer<s, a=""> = (state: S, action: A) =&gt; S</s,></p><p>Reducer（也称为 reducing function）函数接受两个参数：之前已经累积运算的结果和当前要被累积的值，返回的是一个新的累积结果。该函数把一个集合归并成一个单值。</p><p>Reducer 的概念来自于是函数式编程，很多语言中都有 reduce API。如在 javascript 中：</p><pre><code>[{x:1},{y:2},{z:3}].reduce(function(prev, next){    return Object.assign(prev, next);})//return {x:1, y:2, z:3}</code></pre><p>在 dva 中，reducers 聚合积累的结果是当前 model 的 state 对象。通过 actions 中传入的值，与当前 reducers 中的值进行运算获得新的值（也就是新的 state）。<br>需要注意的是 Reducer 必须是纯函数，所以同样的输入必然得到同样的输出，它们不应该产生任何副作用。并且，每一次的计算都应该使用immutable data，这种特性简单理解就是每次操作都是返回一个全新的数据（独立，纯净），所以热重载和时间旅行这些功能才能够使用。</p><p>Effect</p><p>Effect 被称为副作用，在我们的应用中，最常见的就是异步操作。它来自于函数编程的概念，之所以叫副作用是因为它使得我们的函数变得不纯，同样的输入不一定获得同样的输出。</p><p>dva 为了控制副作用的操作，底层引入了redux-sagas做异步流程控制，由于采用了generator的相关概念，所以将异步转成同步写法，从而将effects转为纯函数。至于为什么我们这么纠结于 纯函数，如果你想了解更多可以阅读Mostly adequate guide to FP，或者它的中文译本JS函数式编程指南。</p><p>Subscription</p><p>Subscriptions 是一种从 源 获取数据的方法，它来自于 elm。</p><p>Subscription 语义是订阅，用于订阅一个数据源，然后根据条件 dispatch 需要的 action。数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。</p><pre><code>import key from &apos;keymaster&apos;;...app.model({  namespace: &apos;count&apos;,  subscriptions: {    keyEvent(dispatch) {      key(&apos;⌘+up, ctrl+up&apos;, () =&gt; { dispatch({type:&apos;add&apos;}) });    },  }});</code></pre><p>Router</p><p>这里的路由通常指的是前端路由，由于我们的应用现在通常是单页应用，所以需要前端代码来控制路由逻辑，通过浏览器提供的 History API 可以监听浏览器url的变化，从而控制路由相关操作。</p><p>dva 实例提供了 router 方法来控制路由，使用的是react-router。</p><pre><code>import { Router, Route } from &apos;dva/router&apos;;app.router(({history}) =&gt;  &lt;Router history={history}&gt;    &lt;Route path=&quot;/&quot; component={HomePage} /&gt;  &lt;/Router&gt;);</code></pre><p>Route Components</p><p>在组件设计方法中，我们提到过 Container Components，在 dva 中我们通常将其约束为 Route Components，因为在 dva 中我们通常以页面维度来设计 Container Components。</p><p>所以在 dva 中，通常需要 connect Model的组件都是 Route Components，组织在/routes/目录下，而/components/目录下则是纯组件（Presentational Components）。</p><p><strong>五.  hoc</strong></p><p>  HOC(全称Higher-order component)是一种React的进阶使用方法，主要还是为了便于组件的复用。HOC就是一个方法，获取一个组件，返回一个更高级的组件。</p><p>  在React开发过程中，发现有很多情况下，组件需要被”增强”，比如说给组件添加或者修改一些特定的props，一些权限的管理，或者一些其他的优化之类的。而如果这个功能是针对多个组件的，同时每一个组件都写一套相同的代码，明显显得不是很明智，所以就可以考虑使用HOC。</p><p>  一个最简单的HOC实现是这个样子的：</p><p>  HOC可以做什么？</p><p>  代码复用，代码模块化</p><p>  增删改props</p><p>  渲染劫持</p><p>  1.增删改props</p><p>  可以通过对传入的props进行修改，或者添加新的props来达到增删改props的效果。</p><p>  比如你想要给wrappedComponent增加一个props，可以这么搞：</p><p>  这样，你就可以在你的组件中使用message这个props:</p><p>  2.渲染劫持</p><p>  这里的渲染劫持并不是你能控制它渲染的细节，而是控制是否去渲染。由于细节属于组件内部的render方法控制，所以你无法控制渲染细节。</p><p>  比如，组件要在data没有加载完的时候，现实loading…，就可以这么写：</p><p>  这个样子，在父级没有传入data的时候，这一块儿就只会显示loading…,不会显示组件的具体内容</p><p><strong>六. 项目中的实践</strong></p><ol><li><p>合理使用有状态组件及无状态组件。在使用redux或者dva的场景下，理论上所有的组件都可以封装为无状态组件（少数需要生命周期控制或者上文提到的混合式组件除外），model中封装数据、异步effects及同步reducers，通过connect绑定到对应的组件上。<br>最佳实践： router中getcomponent中定义的组件我们称之为路由组件，一般路由组件会通过connect绑定model中定义的state及组件中定义的方法到该组件的props上。其他方式定义的为非路由组件，非路由组件尽量避免使用connect，而是通过路由组件或者其他上层通过props传递数据进行渲染。</p></li><li><p>理解subscription, effects及reducers中各自的功能职责。</p></li><li><p>package.json中定义的dependency，需要深入研究，避免重复造轮子。</p></li><li><p>全局观及合理的组件规划。</p></li></ol>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/05/react%E4%B8%8Eredux-dva/#disqus_thread</comments>
    </item>
    
    <item>
      <title>react-router的一些问题</title>
      <link>https://github.com/wubianluoye/2017/12/05/react-router%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
      <guid>https://github.com/wubianluoye/2017/12/05/react-router%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Tue, 05 Dec 2017 03:54:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;react-router 有很多个版本，所以有很多个写法，在npm安装时，需要根据route的版本来找api，不然要被坑死！&lt;/p&gt;
&lt;p&gt;react-router 4 版本&lt;a href=&quot;https://reacttraining.cn/web/guides/quick
        
      
      </description>
      
      <content:encoded><![CDATA[<p>react-router 有很多个版本，所以有很多个写法，在npm安装时，需要根据route的版本来找api，不然要被坑死！</p><p>react-router 4 版本<a href="https://reacttraining.cn/web/guides/quick-start" target="_blank" rel="noopener">https://reacttraining.cn/web/guides/quick-start</a></p><p> 这个不知道是几的版本<a href="https://react-guide.github.io/react-router-cn/，貌似安装后里面没有Link模块。demo报错" target="_blank" rel="noopener">https://react-guide.github.io/react-router-cn/，貌似安装后里面没有Link模块。demo报错</a></p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/05/react-router%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
