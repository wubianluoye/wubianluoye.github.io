<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>wubianluoye</title>
    <link>https://github.com/wubianluoye/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="%5Bobject%20Object%5D" rel="hub"/>
    <description></description>
    <pubDate>Tue, 05 Dec 2017 01:57:54 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>关于splice和slice</title>
      <link>https://github.com/wubianluoye/2017/12/05/%E5%85%B3%E4%BA%8Esplice%E5%92%8Cslice/</link>
      <guid>https://github.com/wubianluoye/2017/12/05/%E5%85%B3%E4%BA%8Esplice%E5%92%8Cslice/</guid>
      <pubDate>Tue, 05 Dec 2017 01:42:19 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;strong&gt;splice()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。&lt;/p&gt;
&lt;p&gt;splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。&lt;/p&gt;
&lt;p&gt;如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>splice()</strong></p><p>splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。</p><p>splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。</p><p>如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。<br><a id="more"></a></p><table><br>  <tr><br><br>    <th width="40%," bgcolor="skyblue">参数</th><br>    <th width="50%" ,="" bgcolor="skyblue">描述</th><br>  </tr><br>  <tr><br>    <td> index 必需。 </td><br>    <td> 整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</td><br>  </tr><br>  <tr><br>    <td>howmany 必需。</td><br>    <td>要删除的项目数量。如果设置为 0，则不会删除项目。</td><br>  </tr><tr><br>    <td>item1, …, itemX 可选。</td><br>    <td> itemX 可选。向数组添加的新项目。</td><br>  </tr><br></table><p><strong>slice()</strong></p><p>slice() 方法可从已有的数组中返回选定的元素。</p><p><strong>语法</strong></p><p><strong>arrayObject.slice(start,end)</strong></p><p><strong>返回值</strong></p><p>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。<br>请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。</p><table><br>  <tr><br><br>    <th width="40%," bgcolor="skyblue">参数</th><br>    <th width="50%" ,="" bgcolor="skyblue">描述</th><br>  </tr><br>  <tr><br>    <td>start 必需。</td><br>    <td>规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</td><br>  </tr><br>  <tr><br>    <td>end 可选。</td><br>    <td>规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</td><br><br></tr></table>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/05/%E5%85%B3%E4%BA%8Esplice%E5%92%8Cslice/#disqus_thread</comments>
    </item>
    
    <item>
      <title>chrome插件开发api文档</title>
      <link>https://github.com/wubianluoye/2017/12/05/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91api%E6%96%87%E6%A1%A3/</link>
      <guid>https://github.com/wubianluoye/2017/12/05/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91api%E6%96%87%E6%A1%A3/</guid>
      <pubDate>Tue, 05 Dec 2017 01:36:20 GMT</pubDate>
      <description>
      
        
        
          &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://link.juejin.im/?target=http%3A%2F%2Fopen.chrome.360.cn%2Fextension_dev%2Foverview.html&quot; target=&quot;_blank&quot; rel=&quot;no
        
      
      </description>
      
      <content:encoded><![CDATA[<ul><li><p><a href="https://link.juejin.im/?target=http%3A%2F%2Fopen.chrome.360.cn%2Fextension_dev%2Foverview.html" target="_blank" rel="noopener">360–扩展开发文档</a></p></li><li><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fchajian.baidu.com%2Fdeveloper%2Fextensions%2Fapi_index.html" target="_blank" rel="noopener">JavaScript API -百度浏览器应用开发文档</a></p></li><li><p><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.ituring.com.cn%2Fbook%2F1421" target="_blank" rel="noopener">Chrome扩展及应用开发（首发版）</a></p></li><li><p><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.cnblogs.com%2Fchampagne%2Ftag%2FGoogle%2520Chrome%25E6%2589%25A9%25E5%25B1%2595%2F" target="_blank" rel="noopener">Chrome扩展开发极客</a></p></li></ul>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/05/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91api%E6%96%87%E6%A1%A3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>webpack3.0躺坑css处理与es6编译</title>
      <link>https://github.com/wubianluoye/2017/12/01/webpack3-0%E8%BA%BA%E5%9D%91css%E5%A4%84%E7%90%86%E4%B8%8Ees6%E7%BC%96%E8%AF%91/</link>
      <guid>https://github.com/wubianluoye/2017/12/01/webpack3-0%E8%BA%BA%E5%9D%91css%E5%A4%84%E7%90%86%E4%B8%8Ees6%E7%BC%96%E8%AF%91/</guid>
      <pubDate>Fri, 01 Dec 2017 07:30:34 GMT</pubDate>
      <description>
      
        &lt;p&gt;Webpack3.0小案例躺坑css处理与ES6编译&lt;/p&gt;
&lt;p&gt;css的编译与加载，基于style-loader、css-loader、postcss-loader、autoprefixer以及css预处理(以less为例)。&lt;br&gt;ES6的编译与加载，babel-preset-env代替babel-preset-2015。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Webpack3.0小案例躺坑css处理与ES6编译</p><p>css的编译与加载，基于style-loader、css-loader、postcss-loader、autoprefixer以及css预处理(以less为例)。<br>ES6的编译与加载，babel-preset-env代替babel-preset-2015。<br><a id="more"></a><br>css与js静态资源分割及注意事项，基于插件 extract-text-webpack-plugin。<br>css资源文件的编译与加载</p><p>css最基本的编译要依靠于style-loader、css-loader这两个加载器，所谓最基本，就是在不考虑使用css预处理器以及css后处理器的情况。预处理器包括less、scss、sass、stylus，后处理器如postcss的autoprefixer等。首先我们先弄明白各加载器的作用：</p><p>style-loader，将所有处理好的css样式以行内元素style标签的格式动态注入到界面的head标签中去。<br>css-loader，用来处理css样式，例如把css中类似@import()或者url()这样的引用资源进行引入或者处理。<br>autoprefixer，postcss提供用来自动处理css在不同浏览器之间前缀等问题，从这里我们也可以看出，使用autoprefixer需要先引入postcss。<br>预处理-loader，所有预处理器都是以css为终点生成文件的一种专门的编程语言，为css增加了一些编程特性。<br>了解了这些加载器各自的职能，那我们现在先小试牛刀，用代码来体验一下。</p><p>style-loader &amp;&amp; css-loader</p><p>1、首先，我们在src项目文件夹下新建css文件夹，并新增一样式文件common.css，并写一些全局的css</p><p>html,<br>body {<br>    margin: 0;<br>    padding: 0;<br>    width: 100%;<br>    height: 100%;<br>    background: linear-gradient(to bottom, #abcdef, #f3f5f7);<br>}<br>2、安装css-loader和style-loader，进入到命令行，执行</p><p>cnpm i style-loader css-loader –save-dev<br>3、现在我们在入口文件app.js中去引入我们的common.css：</p><p> //app.js<br> import ‘./css/common.css’;<br> …<br>4、webpack配置，打开webpack.config.js,新增module配置项：</p><p>let path = require(‘path’);<br>…<br>module.exports = {<br>    entry: path.resolve(<strong>dirname, ‘./src/main.js’),//入口文件地址<br>    output: {<br>        path: path.resolve(</strong>dirname, ‘./dist’),<br>        filename: ‘js/[name]-[chunkhash].js’<br>    },<br>    module: {<br>        rules: [ {<br>            test: /.css$/,//匹配所有css文件<br>            use: [<br>                { loader: “style-loader” },<br>                { loader: “css-loader” }<br>             ]//指定加载器<br>            exclude: /node_modules///排除对node_module文件夹下面的所有资源的匹配<br>        }]<br>    },<br>    …<br>}<br>需要注意，在指定加载器的时候，要注意各加载器的顺序，webpack中loader的解析是从右往左的顺序进行的，以当前为例，css文件首先是要通过css-loader进行处理，在将处理好的css交由style-loader，因此在指定加载器的时候，首先应该是style-loader,其次是css-loader。</p><p>现在，我们再次执行webpack编译命令，在浏览器中打开生成的index.html，发现页面背景已经如我们设置改变了,并且html文档中css也已经以style模式注入到head中了。</p><p>style-loader与css-loader加载<br>style-loader与css-loader加载<br>autoprefixer</p><p>上文我们已经说过，autoprefixer是css后处理器postcss提供的一个对css3中个别属性在不同浏览器下需要添加浏览器前缀的样式处理工具，因此在使用autoprefixer之前，我们需要安装postcss-loader来加载它。</p><p> cnpm i postcss-loader autoprefixer –save-dev<br>1、现在，我们打开webpack.config.js配置文件，在module下配置autoprefixer</p><p>…<br>module: {<br>        rules: [{<br>            test: /.css$/,<br>            use: [<br>                { loader: “style-loader” },<br>                { loader: “css-loader” },<br>                { loader: “postcss-loader” }//指定postcss加载器<br>            ],<br>            exclude: /node_modules/<br>        }]<br>    }<br>    …<br>在配置postcss-loader之后，我们需要注意，由于css-loader处理文件导入的方式，因此加载器postcss-loader不能与CSS模块一起使用。 为了使它们正常工作，可以添加css-loader的importLoaders选项。。<br>…<br>module: {<br>        rules: [{<br>            test: /.css$/,<br>            use: [<br>                { loader: “style-loader” },<br>                { loader: “css-loader”,options: { importLoaders: 1 } },//importLoaders解决由于css-loader处理文件导入的方式导致postcss-loader不能正常使用的问题<br>                { loader: “postcss-loader” }//指定postcss加载器<br>            ],<br>            exclude: /node_modules/<br>        }]<br>    }<br>    …<br>2、接下来，我们要给postcss-loader指定加载autoprefixer的操作，在根目录新建postcss.config.js</p><p>//postcss.config.js<br>module.exports = {<br>    plugins: [<br>        require(“autoprefixer”)()<br>    ]<br>}<br>在postcss.config.js配置文件中，我们给引入了autoprefixer,这样一来，在postcss-loader加载的时候，就会自动去读取该配置文件里面的配置项，加载autoprefixer了。</p><p>3、所有配置项已经完成，现在我们在原有的common.css文件中去添加样式，用来测试autoprefixer</p><p>html,<br>body {<br>    margin: 0;<br>    padding: 0;<br>    width: 100%;<br>    height: 100%;<br>    background: linear-gradient(to bottom, #abcdef, #f3f5f7);<br>}</p><p>.flexbox {<br>    display: flex;<br>    background: linear-gradient(to bottom, #abcdef, #096)<br>}<br>添加完成后，运行webpack命令进行编译，并在浏览器中打开index.html，打开控制台查看head标签下生成的style标签，已经可以看到autoprefixer已经自动为我们添加了浏览器前缀</p><p>autoprefixer<br>autoprefixer<br>autoprefixer 为我们提供了可以根据需求配置的参数，例如我么可以让它最终生成的css兼容最近的N个版本就好，但这不是我们本次讨论的重点，有兴趣的同学可以自己去官网查看。</p><p>//postcss.config.js  设置给最近5个版本的浏览器加前缀<br>module.exports = {<br>    plugins: [<br>        require(“autoprefixer”)({browsers:’last 5 version’})<br>    ]<br>}<br>autoprefixer-set-version<br>autoprefixer-set-version<br>css预处理（less-loader）</p><p>1、在src/css文件夹下新建style.less文件，并添加样式作为测试，并在入口文件app.js中引用该less文件</p><p>@base: #f938ab;</p><p>.box-shadow(@style, @c) when (iscolor(@c)) {<br>  -webkit-box-shadow: @style @c;<br>  box-shadow:         @style @c;<br>}<br>.box-shadow(@style, @alpha: 50%) when (isnumber(@alpha)) {<br>  .box-shadow(@style, rgba(0, 0, 0, @alpha));<br>}<br>.box {<br>  color: saturate(@base, 5%);<br>  border-color: lighten(@base, 30%);<br>  div { .box-shadow(0 0 5px, 30%) }<br>}<br> //app.js<br>import ‘./css/common.css’;//引入css<br>import ‘./css/style.less’;//引入less<br>2、安装less以及less-loader，并在webpack配置项中进行配置。</p><p>cnpm i less less-loader –save-dev<br>在module配置项中新增一条对less文件处理的规则：</p><p> …<br> module: {<br>        rules: [{<br>            test: /.css$/,<br>            use: [<br>                { loader: “style-loader” },<br>                { loader: “css-loader”, options: { importLoaders: 1 } },<br>                { loader: “postcss-loader” },<br>            ],<br>            exclude: /node_modules/<br>        }, {<br>            test: /.less$/,<br>            use: [<br>                { loader: “style-loader” },<br>                { loader: “css-loader”, options: { importLoaders: 1 } },<br>                { loader: “postcss-loader” },<br>                { loader: “less-loader” }//less放在最后，因为要最先加载（loader从右往左加载的规则）<br>            ]<br>        }]<br>    },<br>…<br>配置完成后，再次运行webpack命令，并在浏览器中查看效果，可以看到在head标签内又新增了一个style标签，并且已经将less编译成css了</p><p>less-loader<br>less-loader<br>Babel编译ES6</p><p>babel是一个js的转码器，将ES6或者ES7转换成ES5或者ES3；babel编译主要依靠于核心库babel-core，也就是说，用ES6进行编程而不需要担心浏览器环境是否支持。</p><p>babel-preset-env代替babel-preset-ES2015</p><p>在此之前，我猜测有很多的同学使用Babel的时候，preset必然会选择ES2015，但是最近babel官方推出了babel-preset-env，并建议在使用的时候选择env代替之前的ES20**。env为我们提供了更智能的编译选择，在此我们就不展开，有兴趣的同学可以去官网深入了解。</p><p>babel-preset-env编译ES6</p><p>1、首先，我们安装babel-loader、babel-core以及babel-preset-env，并在入口文件app.js中新增一段带ES6语法的js。</p><p>cnpm install –save-dev babel-loader babel-core babel-preset-env<br>import ‘./css/common.css’;<br>import ‘./css/style.less’;<br>//生成一个整数随机值，数值大于4则返回成功的Promise对象，否则返回错误的promise对象<br>function getData() {<br>    let promise = new Promise((resolve, reject) =&gt; {<br>        let key = ~~(Math.random() * 10);<br>        let temp = [‘es6’,’babel’]<br>        if (key &gt;= 5) {<br>            let obj = {<br>                msg: “ok”,<br>                data: [key,…temp]<br>            };<br>            resolve.call(this, obj);<br>        } else {<br>            let obj = {<br>                msg: “error”,<br>                data: [key,…temp]<br>            };<br>            reject.call(this, obj);<br>        }<br>    })<br>    return promise<br>}<br>//找到页面中的Dom<br>let container = document.querySelector(‘#app’);<br>//获取返回的结果并打印到界面<br>getData().then((data) =&gt; {<br>    container.innerHTML = JSON.stringify(data)<br>}, (err) =&gt; {<br>    container.innerHTML = JSON.stringify(err)<br>})<br>在这段代码中，我么使用了Promise来返回最后生成的结果，并将结果打印到界面中，其中运用了Promise、箭头函数、解构赋值等ES6的语法</p><p>2、现在，我们去webpack配置文件中新增一条规则：</p><p>…<br>  module: {<br>        rules: [{<br>            test: /.css$/,<br>            use: [<br>                { loader: “style-loader” },<br>                { loader: “css-loader”, options: { importLoaders: 1 } },<br>                { loader: “postcss-loader” }<br>            ],<br>            exclude: /node_modules/<br>        }, {<br>            test: /.less$/,<br>            use: [<br>                { loader: “style-loader” },<br>                { loader: “css-loader”, options: { importLoaders: 1 } },<br>                { loader: “postcss-loader” },<br>                { loader: “less-loader” }<br>            ]<br>        },<br>        //新增规则，编译js<br>        {<br>            test: /.js$/,<br>            loader: ‘babel-loader’,<br>            exclude: /node_modules/<br>        }]<br>    },<br>并且在根目录下新增.babelrc文件，用来存放babel相关的配置：</p><p>//.babelrc<br>{<br>    “presets”: [<br>        [“env”,{<br>            “targets”: {<br>                “chrome”: 52,<br>                “browsers”: [“last 2 versions”, “safari 7”]<br>            }<br>        }]<br>    ]//设置编译场景，并配置目标结果兼容到chrome52版本以上等等。<br>}<br>3、然后我们去根目录下的index.html里面，新增一个div，并且给这个div的id取名app。</p><p>…</p><p><body><br>    <div id="app"></div><br></body><br>…<br>现在我们在命令行运行webpack命令，并在浏览器中刷新界面，可以看到页面输出了我们结果。</p><p>babel编译es6<br>babel编译es6</p><p>并且，在生成的js中发现，通过编译后的js已经不再是es6的写法了,变异后的核心代码如下：<br>…<br>//编译后的js<br>function getData() {<br>    var _this = this;</p><pre><code>var promise = new Promise(function (resolve, reject) {    var key = ~~(Math.random() * 10);    var temp = [&apos;es6&apos;, &apos;babel&apos;];    if (key &gt;= 5) {        var obj = {            msg: &quot;ok&quot;,            data: [key].concat(temp)        };        resolve.call(_this, obj);    } else {        var _obj = {            msg: &quot;error&quot;,            data: [key].concat(temp)        };        reject.call(_this, _obj);    }});return promise;</code></pre><p>}<br>var container = document.querySelector(‘#app’);</p><p>getData().then(function (data) {<br>    container.innerHTML = JSON.stringify(data);<br>}, function (err) {<br>    container.innerHTML = JSON.stringify(err);<br>});<br>…<br>到此，通过babel编译js就基本完成，当然，babel提供了很多的插件和配置项，有兴趣的同学可以深入了解，本文暂不做深层次探讨。</p><p>CSS与JS文件分离</p><p>通过上面的操作，我们已经可以成功的将css和js进行编译打包，但是当我们再次去查看打包后的js文件时，发现js体积很大（目前js大小22kb），我们只是写了几行js而已啊，那么这又是怎么回事？</p><p>实际上，webpack在打包的时候，会把所有的模块，最终打包在一个文件里面，这也是为什么我们的js文件会如此之大，但却没看到有相应的css文件的原因。</p><p>静态资源处理器extract-text-webpack-plugin</p><p>extract-text-webpack-plugin用来实现不同文件的分离，其用法也和之前插件的用法一样。<br>1、安装插件</p><p>cnpm i extract-text-webpack-plugin –save-dev<br>2、在webpack配置项中对之前我们的css编译规则进行更改：</p><p>…<br>//引入插件<br>let extractTextPlugin = require(‘extract-text-webpack-plugin’);<br>//初始化两个实例用于两处规则分别加载<br>let extractCSS = new extractTextPlugin(‘css/[name]-one.css’);<br>let extractLESS = new extractTextPlugin(‘css/[name]-two.css’);</p><p> …<br>  module: {<br>        rules: [{<br>            test: /.css$/,<br>            exclude: /node_modules/,<br>            //extractCSS实例对css进行操作<br>            use: extractCSS.extract([<br>                // { loader: “style-loader” },//style-loader不能和插件一起使用<br>                { loader: “css-loader”, options: { importLoaders: 1 } },<br>                { loader: “postcss-loader” }<br>            ])<br>        }, {<br>            test: /.less$/,<br>            exclude: /node_modules/,<br>            //extractLESS实例对less进行操作<br>            use: extractLESS.extract([<br>                // { loader: “style-loader” },<br>                { loader: “css-loader”, options: { importLoaders: 1 } },<br>                { loader: “postcss-loader” },<br>                { loader: “less-loader” }<br>            ])<br>        }, {<br>            test: /.js$/,<br>            use: [{ loader: “babel-loader” }],<br>            exclude: /node_modules/<br>        }]<br>    },<br>    …<br>     plugins: [<br>        //注册插件<br>        extractCSS,<br>        extractLESS<br>    ]<br>在配置中需要注意一下几点：</p><p>插件不能喝style-loader同时使用，原因是style-loader的作用是获取到js内部的样式并一行内形式插入到head标签中，但是extractTextPlugin插件是将js内部的代码提取成css文件并添加外部引用的方式进行加载。<br>在多处用到extractTextPlugin插件的时候，我们需要对插件进行功能性的拆分，就比如我们的项目中有两处规则用到它，因此我们首先对插件进行两次实例化得到两个实例，并分别用到两个处理规则中。<br>别忘了在plugins下进行注册。<br>最后，我们再看我们生成的js文件，已经只有4kb大小，减少了接近5倍的体积，可想而知，分离出css是很有必要的。</p><p>静态资源分离<br>静态资源分离</p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/01/webpack3-0%E8%BA%BA%E5%9D%91css%E5%A4%84%E7%90%86%E4%B8%8Ees6%E7%BC%96%E8%AF%91/#disqus_thread</comments>
    </item>
    
    <item>
      <title>换电脑怎么更新博客？</title>
      <link>https://github.com/wubianluoye/2017/11/30/%E6%8D%A2%E7%94%B5%E8%84%91%E6%80%8E%E4%B9%88%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%EF%BC%9F/</link>
      <guid>https://github.com/wubianluoye/2017/11/30/%E6%8D%A2%E7%94%B5%E8%84%91%E6%80%8E%E4%B9%88%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%EF%BC%9F/</guid>
      <pubDate>Thu, 30 Nov 2017 10:10:40 GMT</pubDate>
      <description>
      
        &lt;p&gt;其实，Hexo生成的文件里面是有一个.gitignore的，所以它的本意应该也是想我们把这些文件放到GitHub上存放的。&lt;/p&gt;
&lt;p&gt;但是考虑到如果每个GitHub Pages都需要额外的一个仓库存放这些文件，就显得特别冗余了。这个时候就可以用分支的思路！&lt;/p&gt;
&lt;p&gt;一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>其实，Hexo生成的文件里面是有一个.gitignore的，所以它的本意应该也是想我们把这些文件放到GitHub上存放的。</p><p>但是考虑到如果每个GitHub Pages都需要额外的一个仓库存放这些文件，就显得特别冗余了。这个时候就可以用分支的思路！</p><p>一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。<br><a id="more"></a><br>最近我也用GitHub Pages搭建了一个独立博客，想到了这个方法，使用之后真的特别简洁。为了更直观地说明，奉上使用这种方法不同时候的流程：</p><p>一、关于搭建的流程</p><ol><li>创建仓库，<a href="http://CrazyMilk.github.io；" target="_blank" rel="noopener">http://CrazyMilk.github.io；</a></li><li>创建两个分支：master 与 hexo；<br>3.设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；<br>4.使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库；</li><li>在本地<a href="http://CrazyMilk.github.io文件夹下通过Git" target="_blank" rel="noopener">http://CrazyMilk.github.io文件夹下通过Git</a> bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;</li><li>修改_config.yml中的deploy参数，分支应为master；</li><li>依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；</li><li>执行hexo g -d生成网站并部署到GitHub上。</li></ol><p>这样一来，在GitHub上的<a href="http://CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美(" target="_blank" rel="noopener">http://CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美(</a> •̀ ω •́ )y！</p><p>二、关于日常的改动流程在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。</p><ol><li>依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；</li><li><ol><li>然后才执行hexo g -d发布网站到master分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。</li></ol></li></ol><p>三、本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p><ol><li>使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）；</li><li><ol><li>在本地新拷贝的<a href="http://CrazyMilk.github.io文件夹下通过Git" target="_blank" rel="noopener">http://CrazyMilk.github.io文件夹下通过Git</a> bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。</li></ol></li></ol><p>以上就是我采用的方法，虽说文字有点多，但是我个人觉得真的挺高效和简洁的。</p><p>更详细的可以参考我刚写的博文：<a href="https://link.zhihu.com/?target=http%3A//crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%25E6%2590%25AD%25E5%25BB%25BA%25E5%258D%259A%25E5%25AE%25A2/%23more" target="_blank" rel="noopener">GitHub Pages + Hexo搭建博客</a>。</p><p>作者：CrazyMilk<br>链接：<a href="https://www.zhihu.com/question/21193762/answer/79109280" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762/answer/79109280</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/11/30/%E6%8D%A2%E7%94%B5%E8%84%91%E6%80%8E%E4%B9%88%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%EF%BC%9F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>多设备同步hexo博客</title>
      <link>https://github.com/wubianluoye/2017/11/30/%E5%A4%9A%E8%AE%BE%E5%A4%87%E5%90%8C%E6%AD%A5hexo%E5%8D%9A%E5%AE%A2/</link>
      <guid>https://github.com/wubianluoye/2017/11/30/%E5%A4%9A%E8%AE%BE%E5%A4%87%E5%90%8C%E6%AD%A5hexo%E5%8D%9A%E5%AE%A2/</guid>
      <pubDate>Thu, 30 Nov 2017 09:25:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;多设备同步hexo搭建的Github博客&lt;/p&gt;
&lt;p&gt;多设备同步&lt;/p&gt;
&lt;p&gt;同步思路与Github推拉源码思路相同，使用git指令，保持本地的博客文件与Github上的博客文件相同即可，其步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;使用hexo搭建部署Github博客
&lt;/code&gt;&lt;/pre&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>多设备同步hexo搭建的Github博客</p><p>多设备同步</p><p>同步思路与Github推拉源码思路相同，使用git指令，保持本地的博客文件与Github上的博客文件相同即可，其步骤如下：</p><pre><code>使用hexo搭建部署Github博客</code></pre><a id="more"></a><pre><code>// 在本地博客根目录下安装hexonpm install hexo// 初始化hexonpm init// 安装依赖npm install// 安装部署相关的配置npm install hexo-deployer-git详情参考[这里](http://www.jianshu.com/p/e99ed60390a8)上传博客工程上一步部署博客到Github以后，我们可以在Github仓库的master分支上看到我们上传的博客文件。Github主分支但是这个博客文件是不包含hexo配置的，所以我们需要新建分支，使用git指令将带hexo配置的Github工程文件上传到新建的分支上。Github上新建分支在本地博客根目录下使用git指令上传项目到Github:// git初始化git init// 添加仓库地址git remote add origin https://github.com/用户名/仓库名.git// 新建分支并切换到新建的分支git checkout -b 分支名// 添加所有本地文件到gitgit add .// git提交git commit -m &quot;&quot;// 文件推送到hexo分支git push origin hexo其他设备上clone下Github上新建的分支的文件到本地在另一台设备上使用git指令下载Github新建分支上的文件:// 克隆文件到本地git clone -b 分支名 https://github.com/用户名/仓库名.git本地写文章在source-&gt;_posts文件夹下新建md文件，并编辑好保存后：QQ截图20161013120208.png部署到Github// 安装hexonpm install hexo// 注意这里不需要hexo初始化：hexo init；否则之前的hexo配置参数会重置// 安装依赖库npm install// 安装部署相关配置npm install hexo-deployer-git同步项目源文件到Github// 添加源文件git add .// git提交git commit -m &quot;&quot;// 先拉原来Github分支上的源文件到本地，进行合并git pull origin 分支名// 比较解决前后版本冲突后，push源文件到Github的分支git push origin 分支名</code></pre><p>至此多设备同步到此为止。<br>问题解决</p><p>由于公司里的电脑是win 10所以在部署博客的过程中会遇到一些问题，整理如下：</p><pre><code>Deployer not found: git在终端执行命令：npm install hexo-deployer-git --save然后继续执行hexo deploye指令进行部署。fatal: could not read Username for ‘ https://github.com ‘: Invalid argument由于使用的是https协议，安全性较高，所以系统终端不允许部署，所以我们该用 ssh，修改本地博客hexo配置文件_config.yml，将repository参数修改如下：repository: ssh://git@github.com/iNerdStack/inerdstack.github.io继续执行hexo deploye指令进行部署。Could not read from remote repository这是因为系统没有添加github的ssh信任到本机，所以我们要在命令行执行：ssh -T git@github.comyes</code></pre><p>参考：<br><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">【知乎】使用hexo，如果换了电脑怎么更新博客？</a></p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/11/30/%E5%A4%9A%E8%AE%BE%E5%A4%87%E5%90%8C%E6%AD%A5hexo%E5%8D%9A%E5%AE%A2/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
