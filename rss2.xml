<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>wubianluoye</title>
    <link>https://github.com/wubianluoye/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="%5Bobject%20Object%5D" rel="hub"/>
    <description></description>
    <pubDate>Tue, 05 Dec 2017 05:53:55 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>react与redux,dva</title>
      <link>https://github.com/wubianluoye/2017/12/05/react%E4%B8%8Eredux-dva/</link>
      <guid>https://github.com/wubianluoye/2017/12/05/react%E4%B8%8Eredux-dva/</guid>
      <pubDate>Tue, 05 Dec 2017 03:55:38 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;strong&gt;一.  State和 Props&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  state是状态机。&lt;/p&gt;
&lt;p&gt;  应该包括：那些可能被组件的事件处理器改变并触发用户界面更新的数据，譬如需要对用户输入,服务器请求或者时间变化等作出响应。&lt;/p&gt;
&lt;p&gt;  不应该包括：计算所得数据、React组件（在render()里使用props和state来创建它）、基于props的重复数据（尽可能保持用props来做作为唯一的数据来源，把props保存到state中的有效的场景是需要知道它以前的值得时候,因为未来的props可能会变化）。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>一.  State和 Props</strong></p><p>  state是状态机。</p><p>  应该包括：那些可能被组件的事件处理器改变并触发用户界面更新的数据，譬如需要对用户输入,服务器请求或者时间变化等作出响应。</p><p>  不应该包括：计算所得数据、React组件（在render()里使用props和state来创建它）、基于props的重复数据（尽可能保持用props来做作为唯一的数据来源，把props保存到state中的有效的场景是需要知道它以前的值得时候,因为未来的props可能会变化）。</p><a id="more"></a><p>  props： 父级向子级传递数据的方式。</p><p><strong>二.  有状态组件和无状态组件（纯函数组件）</strong></p><p>  有状态组件</p><p>  通过React.createClass或者es6的class继承React.Component创建的组件。特性：具备完整的生命周期及实例化过程、支持this及ref指向。</p><p>  无状态组件：</p><p>  即stateless component( pure function Component)。以函数返回值方式方式创建的组件。特点： 无实例化过程及生命周期、无this及ref指向、函数接受props及context两个参数。</p><p>  实践模式</p><p>  创建多个只负责渲染数据的无状态(stateless)组件,在他们的上层创建一个有状态(stateful)组件并把它的状态通过props传给子级。有状态的组件封装了所有的用户交互逻辑，state中处理状态的变化, 而这些无状态组件只负责声明式地渲染数据.</p><p><strong>三.  受控组件、非受控组件及混合组件</strong></p><p>  有许多的web组件可以被用户的交互发生改变，比如：<code>&lt;input&gt;，&lt;select&gt;</code>。这些组件可以通过输入一些内容或者设置元素的value属性来改变组件的值。但是，因为React是单向数据流绑定的，这些组件可能会变得失控：</p><p>  1.一个维护它自己state里的value值的<code>&lt;Input&gt;</code>组件无法从外部被修改</p><p>  2.一个通过props来设置value值的<code>&lt;Input&gt;</code>组件只能通过外部控制来更新。</p><p>  受控组件：</p><p>  一个受控的<code>&lt;input&gt;</code>应该有一个value属性。渲染一个受控的组件会展示出value属性的值。 </p><p>  一个受控的组件不会维护它自己内部的状态，组件的渲染单纯的依赖于props。也就是说，如果我们有一个通过props来设置value的<code>&lt;input&gt;</code>组件，不管你如何输入，它都只会显示props.value。换句话说，你的组件是只读的。</p><p>  在处理一个受控组件的时候，应该始终传一个value属性进去，并且注册一个onChange的回调函数让组件变得可变。</p><p>  非受控组件</p><p>  一个没有value属性的<code>&lt;Input&gt;</code>就是一个非受控组件。通过渲染的元素，任意的用户输入都会被立即反映出来。非受控的<code>&lt;Input&gt;</code>只能通过OnChange函数来向上层通知自己被用户输入的更改。</p><p>  混合组件</p><p>  同时维护props.value和state.value的值。props.value在展示上拥有更高的优先级，state.value代表着组件真正的值。</p><p>  目的：</p><p>  1、支持传入值； </p><p>  2、可控：组件外部修改props可改变input组件的真实值及显示值； </p><p>  3、非可控：输入框中输入值，可同时改变input组件的真实值及显示值。</p><p><strong>四.  redux和dva</strong></p><p>  Redux</p><ol><li><p>Actions、Reducers 和 Store</p><p>action 可以理解为应用向 store 传递的数据信息（一般为用户交互信息）。在实际应用中，传递的信息可以约定一个固定的数据格式，比如: Flux Standard Action。 dispatch(action) 是一个同步的过程：执行 reducer 更新 state -&gt; 调用 store 的监听处理函数。如果需要在 dispatch 时执行一些异步操作（fetch action data），可以通过引入 Middleware 解决。</p><p>reducer 实际上就是一个函数：(previousState, action) =&gt; newState。用来执行根据指定 action 来更新 state 的逻辑。reducer 不存储 state, reducer 函数逻辑中不应该直接改变 state 对象, 而是返回新的 state 对象。</p><p>store 是一个单一对象，redux中只有唯一一个store实例。主要作用：</p><ol><li>管理应用的 state</li><li>通过 store.getState() 可以获取 state</li><li>通过 store.dispatch(action) 来触发 state 更新</li><li>通过 store.subscribe(listener) 来注册 state 变化监听器</li></ol></li></ol><ol><li>Dva</li></ol><p>数据流向</p><p>数据的改变发生通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，当此类行为会改变数据的时候可以通过 dispatch 发起一个 action，如果是同步行为会直接通过 Reducers 改变 State ，如果是异步行为（副作用）会先触发 Effects 然后流向 Reducers 最终改变 State，所以在 dva 中，数据流向非常清晰简明，并且思路基本跟开源社区保持一致（也是来自于开源社区）。</p><p>Modele</p><p>State</p><p>type State = any</p><p>State 表示 Model 的状态数据，通常表现为一个 javascript 对象（当然它可以是任何值）；操作的时候每次都要当作不可变数据（immutable data）来对待，保证每次都是全新对象，没有引用关系，这样才能保证 State 的独立性，便于测试和追踪变化。<br>在 dva 中你可以通过 dva 的实例属性 _store 看到顶部的 state 数据，但是通常你很少会用到:<br>    const app = dva();<br>    console.log(app._store); // 顶部的 state 数据</p><p>Action</p><p>type AsyncAction = any</p><p>Action 是一个普通 javascript 对象，它是改变 State 的唯一途径。无论是从 UI 事件、网络回调，还是 WebSocket 等数据源所获得的数据，最终都会通过 dispatch 函数调用一个 action，从而改变对应的数据。action 必须带有 type 属性指明具体的行为，其它字段可以自定义，如果要发起一个 action 需要使用 dispatch 函数；需要注意的是 dispatch 是在组件 connect Models以后，通过 props 传入的。</p><pre><code>dispatch({  type: &apos;add&apos;,});</code></pre><p>dispatch 函数</p><p>type dispatch = (a: Action) =&gt; Action</p><p>dispatching function 是一个用于触发 action 的函数，action 是改变 State 的唯一途径，但是它只描述了一个行为，而 dipatch 可以看作是触发这个行为的方式，而 Reducer 则是描述如何改变数据的。<br>在 dva 中，connect Model 的组件通过 props 可以访问到 dispatch，可以调用 Model 中的 Reducer 或者 Effects，常见的形式如：</p><pre><code>dispatch({  type: &apos;user/add&apos;, // 如果在 model 外调用，需要添加 namespace  payload: {}, // 需要传递的信息    });</code></pre><p>Reducer</p><p>type Reducer<s, a=""> = (state: S, action: A) =&gt; S</s,></p><p>Reducer（也称为 reducing function）函数接受两个参数：之前已经累积运算的结果和当前要被累积的值，返回的是一个新的累积结果。该函数把一个集合归并成一个单值。</p><p>Reducer 的概念来自于是函数式编程，很多语言中都有 reduce API。如在 javascript 中：</p><pre><code>[{x:1},{y:2},{z:3}].reduce(function(prev, next){    return Object.assign(prev, next);})//return {x:1, y:2, z:3}</code></pre><p>在 dva 中，reducers 聚合积累的结果是当前 model 的 state 对象。通过 actions 中传入的值，与当前 reducers 中的值进行运算获得新的值（也就是新的 state）。<br>需要注意的是 Reducer 必须是纯函数，所以同样的输入必然得到同样的输出，它们不应该产生任何副作用。并且，每一次的计算都应该使用immutable data，这种特性简单理解就是每次操作都是返回一个全新的数据（独立，纯净），所以热重载和时间旅行这些功能才能够使用。</p><p>Effect</p><p>Effect 被称为副作用，在我们的应用中，最常见的就是异步操作。它来自于函数编程的概念，之所以叫副作用是因为它使得我们的函数变得不纯，同样的输入不一定获得同样的输出。</p><p>dva 为了控制副作用的操作，底层引入了redux-sagas做异步流程控制，由于采用了generator的相关概念，所以将异步转成同步写法，从而将effects转为纯函数。至于为什么我们这么纠结于 纯函数，如果你想了解更多可以阅读Mostly adequate guide to FP，或者它的中文译本JS函数式编程指南。</p><p>Subscription</p><p>Subscriptions 是一种从 源 获取数据的方法，它来自于 elm。</p><p>Subscription 语义是订阅，用于订阅一个数据源，然后根据条件 dispatch 需要的 action。数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。</p><pre><code>import key from &apos;keymaster&apos;;...app.model({  namespace: &apos;count&apos;,  subscriptions: {    keyEvent(dispatch) {      key(&apos;⌘+up, ctrl+up&apos;, () =&gt; { dispatch({type:&apos;add&apos;}) });    },  }});</code></pre><p>Router</p><p>这里的路由通常指的是前端路由，由于我们的应用现在通常是单页应用，所以需要前端代码来控制路由逻辑，通过浏览器提供的 History API 可以监听浏览器url的变化，从而控制路由相关操作。</p><p>dva 实例提供了 router 方法来控制路由，使用的是react-router。</p><pre><code>import { Router, Route } from &apos;dva/router&apos;;app.router(({history}) =&gt;  &lt;Router history={history}&gt;    &lt;Route path=&quot;/&quot; component={HomePage} /&gt;  &lt;/Router&gt;);</code></pre><p>Route Components</p><p>在组件设计方法中，我们提到过 Container Components，在 dva 中我们通常将其约束为 Route Components，因为在 dva 中我们通常以页面维度来设计 Container Components。</p><p>所以在 dva 中，通常需要 connect Model的组件都是 Route Components，组织在/routes/目录下，而/components/目录下则是纯组件（Presentational Components）。</p><p><strong>五.  hoc</strong></p><p>  HOC(全称Higher-order component)是一种React的进阶使用方法，主要还是为了便于组件的复用。HOC就是一个方法，获取一个组件，返回一个更高级的组件。</p><p>  在React开发过程中，发现有很多情况下，组件需要被”增强”，比如说给组件添加或者修改一些特定的props，一些权限的管理，或者一些其他的优化之类的。而如果这个功能是针对多个组件的，同时每一个组件都写一套相同的代码，明显显得不是很明智，所以就可以考虑使用HOC。</p><p>  一个最简单的HOC实现是这个样子的：</p><p>  HOC可以做什么？</p><p>  代码复用，代码模块化</p><p>  增删改props</p><p>  渲染劫持</p><p>  1.增删改props</p><p>  可以通过对传入的props进行修改，或者添加新的props来达到增删改props的效果。</p><p>  比如你想要给wrappedComponent增加一个props，可以这么搞：</p><p>  这样，你就可以在你的组件中使用message这个props:</p><p>  2.渲染劫持</p><p>  这里的渲染劫持并不是你能控制它渲染的细节，而是控制是否去渲染。由于细节属于组件内部的render方法控制，所以你无法控制渲染细节。</p><p>  比如，组件要在data没有加载完的时候，现实loading…，就可以这么写：</p><p>  这个样子，在父级没有传入data的时候，这一块儿就只会显示loading…,不会显示组件的具体内容</p><p><strong>六. 项目中的实践</strong></p><ol><li><p>合理使用有状态组件及无状态组件。在使用redux或者dva的场景下，理论上所有的组件都可以封装为无状态组件（少数需要生命周期控制或者上文提到的混合式组件除外），model中封装数据、异步effects及同步reducers，通过connect绑定到对应的组件上。<br>最佳实践： router中getcomponent中定义的组件我们称之为路由组件，一般路由组件会通过connect绑定model中定义的state及组件中定义的方法到该组件的props上。其他方式定义的为非路由组件，非路由组件尽量避免使用connect，而是通过路由组件或者其他上层通过props传递数据进行渲染。</p></li><li><p>理解subscription, effects及reducers中各自的功能职责。</p></li><li><p>package.json中定义的dependency，需要深入研究，避免重复造轮子。</p></li><li><p>全局观及合理的组件规划。</p></li></ol>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/05/react%E4%B8%8Eredux-dva/#disqus_thread</comments>
    </item>
    
    <item>
      <title>react-router的一些问题</title>
      <link>https://github.com/wubianluoye/2017/12/05/react-router%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
      <guid>https://github.com/wubianluoye/2017/12/05/react-router%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Tue, 05 Dec 2017 03:54:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;react-router 有很多个版本，所以有很多个写法，在npm安装时，需要根据route的版本来找api，不然要被坑死！&lt;/p&gt;
&lt;p&gt;react-router 4 版本&lt;a href=&quot;https://reacttraining.cn/web/guides/quick
        
      
      </description>
      
      <content:encoded><![CDATA[<p>react-router 有很多个版本，所以有很多个写法，在npm安装时，需要根据route的版本来找api，不然要被坑死！</p><p>react-router 4 版本<a href="https://reacttraining.cn/web/guides/quick-start" target="_blank" rel="noopener">https://reacttraining.cn/web/guides/quick-start</a></p><p> 这个不知道是几的版本<a href="https://react-guide.github.io/react-router-cn/，貌似安装后里面没有Link模块。demo报错" target="_blank" rel="noopener">https://react-guide.github.io/react-router-cn/，貌似安装后里面没有Link模块。demo报错</a></p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/05/react-router%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>react组件间通信</title>
      <link>https://github.com/wubianluoye/2017/12/05/react%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/</link>
      <guid>https://github.com/wubianluoye/2017/12/05/react%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/</guid>
      <pubDate>Tue, 05 Dec 2017 03:39:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;父组件可以给子组件传递属性，&lt;/p&gt;
&lt;p&gt;父组件可以调用子组件的方法 ref，因为ref可以形成一条链，所以父辈组件可以调用到任何子孙组件的方法，其实可以直接更改状&lt;/p&gt;
&lt;p&gt;态，不要这么做，会降低组件的内聚度，提高组件间的耦合度&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>父组件可以给子组件传递属性，</p><p>父组件可以调用子组件的方法 ref，因为ref可以形成一条链，所以父辈组件可以调用到任何子孙组件的方法，其实可以直接更改状</p><p>态，不要这么做，会降低组件的内聚度，提高组件间的耦合度</p><a id="more"></a><p>子组件可以调用父组件的方法，前提是父组件已经把方法传递给子组件了</p><p>这样的话，只要外层有至少一个共同的父组件，这两个组件就都可以通过共同的父组件进行通信</p><pre><code>React.addons.LinkedStateMixin         为 react提供的 双向绑定的react-with-addons.min.jsmixins:[React.addons.LinkedStateMixin]&lt;input type=&quot;text&quot; onClick={this.linkState(&apos;name&apos;)} style={{margin:"5px 0"}}/&gt;</code></pre><p>双向绑定。。<br>为单个数据挂载。。</p><pre><code>sexc:function(e){    this.setState({        sex:e.target.value    })}</code></pre><p>一个函数处理多个事件</p><pre><code>aal:function(type){    var that=this;    return function(e){        var obj={};        obj[type]=e.target.value;        that.setState(obj);    }}&lt;div&gt;&lt;input type=&quot;text&quot; onChange={this.aal(&apos;age&apos;)} style={{margin:"5px 0"}} /&gt;{this.state.age}&lt;input type=&quot;text&quot; onChange={this.aal(&apos;name&apos;)} style={{margin:"5px 0"}} /&gt;{this.state.age}&lt;input type=&quot;text&quot; onChange={this.aal(&apos;sex&apos;)} style={{margin:"5px 0"}} /&gt;{this.state.age}&lt;/div&gt;</code></pre>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/05/react%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>keep-alive使复用子组件不刷新</title>
      <link>https://github.com/wubianluoye/2017/12/05/keep-alive%E4%BD%BF%E5%A4%8D%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%8D%E5%88%B7%E6%96%B0/</link>
      <guid>https://github.com/wubianluoye/2017/12/05/keep-alive%E4%BD%BF%E5%A4%8D%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%8D%E5%88%B7%E6%96%B0/</guid>
      <pubDate>Tue, 05 Dec 2017 03:05:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;问题：在写路由时，通过跳转到同一路由改变id来改变数据，发现只有第一次的数据有用，其他的点击还是第一个路由进来的数据。&lt;/p&gt;
&lt;p&gt;原因：在&lt;router-view&gt;&lt;/router-view&gt;外面加了一层&lt;keep-alive&gt;&lt;/keep-alive&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;keep-alive&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;/keep-alive&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>问题：在写路由时，通过跳转到同一路由改变id来改变数据，发现只有第一次的数据有用，其他的点击还是第一个路由进来的数据。</p><p>原因：在<router-view></router-view>外面加了一层<keep-alive></keep-alive></p><pre><code>&lt;keep-alive&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;</code></pre><a id="more"></a><p>keep-alive 缓存组件在内存中，再次进入该页面不会重新渲染，用于保存页面的原始状态。<br>这就是原因！！！</p><p>解决方法有几种：</p><p>1.删除keep-alive</p><p>2.保留keep-alive，使用$watch()进行检测</p><p>3.保留keep-alive，使用beforeRouteUpdate进行检测</p><p>4.保留keep-alive，使用beforeRouteEnter 进行检测</p><pre><code>beforeRouteEnter (to, from, next) {  next(vm =&gt; {    vm.getdata()  })}</code></pre>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/05/keep-alive%E4%BD%BF%E5%A4%8D%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%8D%E5%88%B7%E6%96%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>常用正则表达式</title>
      <link>https://github.com/wubianluoye/2017/12/05/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <guid>https://github.com/wubianluoye/2017/12/05/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <pubDate>Tue, 05 Dec 2017 03:00:05 GMT</pubDate>
      <description>
      
        &lt;p&gt;1、最多输入9位数字并且小数点后最多有两位数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/^(\d{1,9}.\d{1,2}|\d{1,9}|0(.\d{1,2})?)$/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、只能输入大写字母&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/^[A-Z]+$/
&lt;/code&gt;&lt;/pre&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>1、最多输入9位数字并且小数点后最多有两位数</p><pre><code>/^(\d{1,9}.\d{1,2}|\d{1,9}|0(.\d{1,2})?)$/</code></pre><p>2、只能输入大写字母</p><pre><code>/^[A-Z]+$/</code></pre><a id="more"></a><p>3、请输入数字和字母</p><pre><code>/^[A-Za-z0-9]+$/</code></pre><p>4、只能输入数字、字母与下划线!</p><pre><code>/^([A-Za-z0-9]|_)+$/</code></pre><p>5、请输入字母</p><pre><code>/^([A-Z]|[a-z])+$/</code></pre><p>6、请输入格式为HH:mm:ss 的时间</p><pre><code>/(?:[01]\d?|2[0-3])(?::[0-5]\d?|60){2}$/</code></pre><p>7、请输入正确的手机号码</p><pre><code>/^0?1[345789]\d{9}$/</code></pre><p>一、校验数字的表达式</p><p>数字：^[0-9]*$</p><p>n位的数字：^\d{n}$</p><p>至少n位的数字：^\d{n,}$</p><p>m-n位的数字：^\d{m,n}$</p><p>零和非零开头的数字：^(0|[1-9][0-9]*)$</p><p>非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$</p><p>带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})?$</p><p>正数、负数、和小数：^(-|+)?\d+(.\d+)?$</p><p>有两位小数的正实数：^[0-9]+(.[0-9]{2})?$</p><p>有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$</p><p>非零的正整数：^[1-9]\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]*$</p><p>非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\d$</p><p>非负整数：^\d+$ 或 ^[1-9]\d*|0$</p><p>非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</p><p>非负浮点数：^\d+(.\d+)?$ 或 ^[1-9]\d.\d|0.\d[1-9]\d|0?.0+|0$</p><p>非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d.\d|0.\d[1-9]\d))|0?.0+|0$</p><p>正浮点数：^[1-9]\d.\d|0.\d[1-9]\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$</p><p>负浮点数：^-([1-9]\d.\d|0.\d[1-9]\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$</p><p>浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d.\d|0.\d[1-9]\d|0?.0+|0)$</p><p>二、校验字符的表达式</p><p>汉字：^[\u4e00-\u9fa5]{0,}$</p><p>英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$</p><p>长度为3-20的所有字符：^.{3,20}$</p><p>由26个英文字母组成的字符串：^[A-Za-z]+$</p><p>由26个大写英文字母组成的字符串：^[A-Z]+$</p><p>由26个小写英文字母组成的字符串：^[a-z]+$</p><p>由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</p><p>由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$</p><p>中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$</p><p>中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$</p><p>可以输入含有^%&amp;’,;=?$\”等字符：[^%&amp;’,;=?$\x22]+</p><p>禁止输入含有~的字符：[^~\x22]+</p><p>三、特殊需求表达式</p><p>Email地址：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$</p><p>域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?InternetURL：[a-zA-z]+://[^\s] 或 ^<a href="http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=])?$" target="_blank" rel="noopener">http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=])?$</a></p><p>手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$</p><p>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$</p><p>国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}</p><p>身份证号：15或18位身份证：^\d{15}|\d{18}$</p><p>15位身份证：^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$</p><p>18位身份证：^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$</p><p>短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$</p><p>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$</p><p>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$</p><p>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$</p><p>日期格式：^\d{4}-\d{1,2}-\d{1,2}</p><p>一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</p><p>一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</p><p>钱的输入格式：</p><p>1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$</p><p>2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$</p><p>3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$</p><p>4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$</p><p>5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$</p><p>6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$</p><p>7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$</p><p>8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$</p><p>备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</p><p>xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+.[x|X][m|M][l|L]$</p><p>中文字符的正则表达式：[\u4e00-\u9fa5]</p><p>双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</p><p>空白行的正则表达式：\n\s*\r (可以用来删除空白行)</p><p>HTML标记的正则表达式：&lt;(\S?)[^&gt;]&gt;.?|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</p><p>首尾空白字符的正则表达式：^\s|\s$或(^\s)|(\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</p><p>腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)</p><p>中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)</p><p>IP地址：\d+.\d+.\d+.\d+ (提取IP地址时有用)</p>]]></content:encoded>
      
      <comments>https://github.com/wubianluoye/2017/12/05/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
